{
    "name": "ERC721OnChain",
    "solcVersion": "0.8.16",
    "solcLongVersion": "0.8.16+commit.07a7930e",
    "input": {
        "language": "Solidity",
        "sources": {
            "contracts/extensions/ERC721ReferenceMintAndMetadataMainnet.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC721ReferenceMintAndMetadataMainnet.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/extensions/IERC721ReferenceMintAndMetadataMainnet.sol\";\n\nimport \"../schain/tokens/ERC721OnChain.sol\";\nimport \"./interfaces/MessageReceiver.sol\";\n\n\n// This contract runs on the main net and accepts deposits\ncontract ERC721ReferenceMintAndMetadataMainnet is MessageReceiver, IERC721ReferenceMintAndMetadataMainnet {\n\n    address public erc721ContractOnMainnet;\n    address public senderContractOnSchain;\n    string public schainName;\n\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender is not an owner\");\n        _;\n    }\n\n    constructor(\n        address newMessageProxyAddress,\n        address newErc721Contract,\n        string memory newSchainName\n    )\n        MessageProxyClient(newMessageProxyAddress)\n    {\n        require(newErc721Contract != address(0), \"ERC721 contract has to be set\");\n        erc721ContractOnMainnet = newErc721Contract;\n        schainName = newSchainName;\n        owner = msg.sender;\n    }\n\n    function setSenderContractOnSchain(address newSenderContractOnSchain) external override onlyOwner {\n        require(newSenderContractOnSchain != address(0), \"Sender contract has to be set\");\n        senderContractOnSchain = newSenderContractOnSchain;\n    }\n\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n    {\n        require(schainHash == keccak256(abi.encodePacked(schainName)), \"Incorrect name of schain\");\n        require(sender == senderContractOnSchain, \"Incorrect sender contract\");\n        address to;\n        uint256 tokenId;\n        string memory tokenURI;\n        (to, tokenId, tokenURI) = abi.decode(data, (address, uint256, string));\n        ERC721OnChain(erc721ContractOnMainnet).mint(address(this), tokenId);\n        require(\n            ERC721OnChain(erc721ContractOnMainnet).setTokenURI(tokenId, tokenURI),\n            \"Token URI was not set\"\n        );\n        ERC721OnChain(erc721ContractOnMainnet).transferFrom(address(this), to, tokenId);\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/extensions/IERC721ReferenceMintAndMetadataMainnet.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IERC721ReferenceMintAndMetadataMainnet.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IERC721ReferenceMintAndMetadataMainnet {\n    function setSenderContractOnSchain(address newSenderContractOnSchain) external;\n}"
            },
            "contracts/schain/tokens/ERC721OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC721OnChain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IERC721OnChain.sol\";\n\n\n/**\n * @title ERC721OnChain\n * @dev ERC721 token that is used as an automatically deployed clone of ERC721 on mainnet.\n */\ncontract ERC721OnChain is\n    AccessControlEnumerableUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    IERC721OnChain\n{\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory contractName,\n        string memory contractSymbol\n    ) initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC721Upgradeable.__ERC721_init(contractName, contractSymbol);\n        ERC721BurnableUpgradeable.__ERC721Burnable_init();\n        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Set URI of ERC721 token.\n     * \n     * Requirements:\n     * \n     * - token with {tokenId} must exist.\n     * - sender must be the token owner or approved for the token.\n     */\n    function setTokenURI(uint256 tokenId, string calldata tokenUri)\n        external\n        override\n        returns (bool)\n    {\n        require(_exists(tokenId), \"Token does not exists\");\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId) ||\n            hasRole(MINTER_ROLE, _msgSender()),\n            \"Sender can not set token URI\"\n        );\n        _setTokenURI(tokenId, tokenUri);\n        return true;\n    }\n\n    /**\n     * @dev Mint token.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(address account, uint256 tokenId)\n        external\n        override\n    {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mint(account, tokenId);\n    }\n\n    /**\n     * @dev Check if contract support {interfaceId} interface.\n     * \n     * See https://eips.ethereum.org/EIPS/eip-165 for more details.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(AccessControlEnumerableUpgradeable, ERC721Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Get token URI.\n     */\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override (ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory) \n    {\n        return ERC721URIStorageUpgradeable.tokenURI(tokenId);\n    }\n\n    // private\n\n    /**\n     * @dev Burn {tokenId}.\n     */\n    function _burn(uint256 tokenId) internal override (ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        ERC721URIStorageUpgradeable._burn(tokenId);\n    }\n}\n"
            },
            "contracts/extensions/interfaces/MessageReceiver.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageReceiver.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\nimport \"./MessageProxyClient.sol\";\n\n\n// solhint-disable-next-line no-empty-blocks\nabstract contract MessageReceiver is MessageProxyClient, IMessageReceiver {}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/tokens/IERC721OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IERC721OnChain - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IERC721OnChain {\n    function setTokenURI(uint256 tokenId, string calldata tokenUri) external returns (bool);\n    function mint(address account, uint256 tokenId) external;\n}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
            },
            "@skalenetwork/ima-interfaces/IMessageReceiver.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IMessageReceiver.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IMessageReceiver {\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external;\n}"
            },
            "contracts/extensions/interfaces/MessageProxyClient.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyClient.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"../../MessageProxy.sol\";\n\nabstract contract MessageProxyClient {\n    MessageProxy public messageProxy;\n\n    modifier onlyMessageProxy() {\n        require(msg.sender == address(messageProxy), \"Sender is not a message proxy\");\n        _;\n    }\n\n    constructor(address newMessageProxyAddress) {\n        messageProxy = MessageProxy(newMessageProxyAddress);\n    }\n}"
            },
            "contracts/MessageProxy.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    // solhint-disable-next-line private-vars-leading-underscore\n    mapping(bytes32 => mapping(address => bool)) internal deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }    \n\n    /**\n     * @dev Sets gasLimit to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     * \n     * Requirements:\n     * \n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     * \n     * Requirements:\n     * \n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     * \n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     * \n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n        \n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }    \n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {      \n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n        \n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );        \n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;    \n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/IGasReimbursable.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IGasReimbursable.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./IMessageReceiver.sol\";\n\n\ninterface IGasReimbursable is IMessageReceiver {\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        returns (address);\n}"
            },
            "@skalenetwork/ima-interfaces/IMessageProxy.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IMessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IMessageProxy {\n\n    /**\n     * @dev Structure that describes message. Should contain sender of message,\n     * destination contract on schain that will receiver message,\n     * data that contains all needed info about token or ETH.\n     */\n    struct Message {\n        address sender;\n        address destinationContract;\n        bytes data;\n    }\n\n    /**\n     * @dev Structure that contains fields for bls signature.\n     */\n    struct Signature {\n        uint256[2] blsSignature;\n        uint256 hashA;\n        uint256 hashB;\n        uint256 counter;\n    }\n\n    function addConnectedChain(string calldata schainName) external;\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    ) external;\n    function setNewGasLimit(uint256 newGasLimit) external;\n    function registerExtraContractForAll(address extraContract) external;\n    function removeExtraContractForAll(address extraContract) external;    \n    function removeConnectedChain(string memory schainName) external;\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    ) external;\n    function registerExtraContract(string memory chainName, address extraContract) external;\n    function removeExtraContract(string memory schainName, address extraContract) external;\n    function setVersion(string calldata newVersion) external;\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    ) external view returns (bool);\n    function getContractRegisteredLength(bytes32 schainHash) external view returns (uint256);\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        returns (address[] memory);\n    function getOutgoingMessagesCounter(string calldata targetSchainName) external view returns (uint256);\n    function getIncomingMessagesCounter(string calldata fromSchainName) external view returns (uint256);\n    function isConnectedChain(string memory schainName) external view returns (bool);\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view returns (uint);\n}"
            },
            "contracts/extensions/interfaces/MessageSender.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageSender.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"./MessageProxyClient.sol\";\n\nabstract contract MessageSender is MessageProxyClient {\n\n    function _sendMessage(\n        string memory targetChainName,\n        address targetContract,\n        bytes memory data\n    ) internal {\n        messageProxy.postOutgoingMessage(keccak256(abi.encodePacked(targetChainName)), targetContract, data);\n    }\n}"
            },
            "contracts/extensions/ERC721ReferenceMintAndMetadataSchain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC721ReferenceMintAndMetadataSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/extensions/IERC721ReferenceMintAndMetadataSchain.sol\";\n\nimport \"../schain/tokens/ERC721OnChain.sol\";\nimport \"./interfaces/MessageSender.sol\";\n\n\n/**\n * @title Token Manager\n * @dev Runs on SKALE Chains, accepts messages from mainnet, and instructs\n * TokenFactory to create clones.\n  When a user exits a SKALE chain, TokenFactory\n * burns tokens.\n */\ncontract ERC721ReferenceMintAndMetadataSchain is MessageSender, IERC721ReferenceMintAndMetadataSchain {\n\n    address public erc721ContractOnSchain;\n    address public receiverContractOnMainnet;\n\n    constructor(\n        address newMessageProxyAddress,\n        address newErc721ContractOnSchain,\n        address newReceiverContractOnMainnet\n    )\n        MessageProxyClient(newMessageProxyAddress)\n    {\n        require(newErc721ContractOnSchain != address(0), \"ERC721 contract has to be set\");\n        require(newReceiverContractOnMainnet != address(0), \"Receiver contract has to be set\");\n        erc721ContractOnSchain = newErc721ContractOnSchain;\n        receiverContractOnMainnet = newReceiverContractOnMainnet;\n    }\n\n    function sendTokenToMainnet(address receiver, uint256 tokenId) external override {\n        require(\n            ERC721OnChain(erc721ContractOnSchain).getApproved(tokenId) == address(this),\n            \"Not allowed ERC721 Token\"\n        );\n        ERC721OnChain(erc721ContractOnSchain).transferFrom(msg.sender, address(this), tokenId);\n        string memory tokenURI = ERC721OnChain(erc721ContractOnSchain).tokenURI(tokenId);\n        ERC721OnChain(erc721ContractOnSchain).burn(tokenId);\n        bytes memory data = encodeParams(receiver, tokenId, tokenURI);\n        _sendMessage(\"Mainnet\", receiverContractOnMainnet, data);\n    }\n\n    function encodeParams(\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    )\n        public\n        pure\n        override\n        returns (bytes memory data)\n    {\n        data = abi.encode(receiver, tokenId, tokenURI);\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/extensions/IERC721ReferenceMintAndMetadataSchain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IERC721ReferenceMintAndMetadataSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IERC721ReferenceMintAndMetadataSchain {\n    function sendTokenToMainnet(address receiver, uint256 tokenId) external;\n    function encodeParams(\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    )\n        external\n        pure\n        returns (bytes memory data);\n}"
            },
            "contracts/schain/TokenManagers/TokenManagerERC721.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC721.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC721OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC721\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC721 clones.\n * TokenManagerERC721 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC721 is TokenManager, ITokenManagerERC721 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC721 on Mainnet => ERC721 on Schain\n    mapping(address => ERC721OnChain) public deprecatedClonesErc721;\n\n    // address clone on schain => added or not\n    mapping(ERC721OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC721OnChain)) public clonesErc721;\n\n    mapping(address => mapping(uint256 => bytes32)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC721;\n\n    /**\n     * @dev Emitted when schain owner register new ERC721 clone.\n     */\n    event ERC721TokenAdded(\n        bytes32 indexed chainHash,\n        address indexed erc721OnMainChain,\n        address indexed erc721OnSchain\n    );\n\n    /**\n     * @dev Emitted when TokenManagerERC721 automatically deploys new ERC721 clone.\n     */\n    event ERC721TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc721OnMainChain,\n        address indexed erc721OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC721TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc721OnMainChain,\n        address indexed erc721OnSchain,\n        uint256 tokenId\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC721TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 tokenId);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC721(\n        address contractOnMainnet,\n        uint256 tokenId\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(MAINNET_HASH, msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, tokenId);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC721(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 tokenId\n    ) \n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        communityLocker.checkAllowedToSendMessage(targetSchainHash, msg.sender);\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, tokenId);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        virtual\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC721_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC721\n        ) {\n            receiver = _sendERC721(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC721 token clone in the token manager.\n     */\n    function addERC721TokenByOwner(\n        string calldata targetChainName,\n        address erc721OnMainChain,\n        address erc721OnSchain\n    )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc721OnSchain.isContract(), \"Given address is not a contract\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc721[targetChainHash][erc721OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC721OnChain(erc721OnSchain)], \"Clone was already added\");\n        clonesErc721[targetChainHash][erc721OnMainChain] = ERC721OnChain(erc721OnSchain);\n        addedClones[ERC721OnChain(erc721OnSchain)] = true;\n        emit ERC721TokenAdded(targetChainHash, erc721OnMainChain, erc721OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override\n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }    \n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC721 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC721(bytes32 fromChainHash, bytes calldata data) internal virtual returns (address) {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        address receiver;\n        address token;\n        uint256 tokenId;\n        ERC721OnChain contractOnSchain;\n        if (messageType == Messages.MessageType.TRANSFER_ERC721) {\n            Messages.TransferErc721Message memory message = Messages.decodeTransferErc721Message(data);\n            receiver = message.receiver;\n            token = message.token;\n            tokenId = message.tokenId;\n            contractOnSchain = clonesErc721[fromChainHash][token];\n        } else {\n            Messages.TransferErc721AndTokenInfoMessage memory message =\n                Messages.decodeTransferErc721AndTokenInfoMessage(data);\n            receiver = message.baseErc721transfer.receiver;\n            token = message.baseErc721transfer.token;\n            tokenId = message.baseErc721transfer.tokenId;\n            contractOnSchain = clonesErc721[fromChainHash][token];\n            if (address(contractOnSchain) == address(0)) {\n                require(automaticDeploy, \"Automatic deploy is disabled\");\n                contractOnSchain = new ERC721OnChain(message.tokenInfo.name, message.tokenInfo.symbol);           \n                clonesErc721[fromChainHash][token] = contractOnSchain;\n                addedClones[contractOnSchain] = true;\n                emit ERC721TokenCreated(fromChainHash, token, address(contractOnSchain));\n            }\n        }\n        if (\n            messageType == Messages.MessageType.TRANSFER_ERC721 &&\n            fromChainHash != MAINNET_HASH &&\n            _schainToERC721[fromChainHash].contains(token)\n        ) {\n            require(token.isContract(), \"Incorrect main chain token\");\n            require(IERC721Upgradeable(token).ownerOf(tokenId) == address(this), \"Incorrect tokenId\");\n            _removeTransferredAmount(fromChainHash, token, tokenId);\n            IERC721Upgradeable(token).transferFrom(address(this), receiver, tokenId);\n        } else {\n            contractOnSchain.mint(receiver, tokenId);\n        }\n        emit ERC721TokenReceived(fromChainHash, token, address(contractOnSchain), tokenId);\n        return receiver;\n    }\n\n    /**\n     * @dev Removes the ids of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc721Token, uint256 tokenId) internal {\n        require(transferredAmount[erc721Token][tokenId] == chainHash, \"Token was already transferred from chain\");\n        transferredAmount[erc721Token][tokenId] = bytes32(0);\n    }\n\n    /**\n     * @dev Allows DepositBoxERC721 to receive ERC721 tokens.\n     * \n     * Emits an {ERC721TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC721.\n     */\n    function _receiveERC721(\n        bytes32 chainHash,\n        address erc721OnMainChain,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        virtual\n        returns (bytes memory data)\n    {\n        bool isERC721AddedToSchain = _schainToERC721[chainHash].contains(erc721OnMainChain);\n        if (!isERC721AddedToSchain) {\n            _addERC721ForSchain(chainHash, erc721OnMainChain);\n            data = Messages.encodeTransferErc721AndTokenInfoMessage(\n                erc721OnMainChain,\n                to,\n                tokenId,\n                _getTokenInfo(IERC721MetadataUpgradeable(erc721OnMainChain))\n            );\n        } else {\n            data = Messages.encodeTransferErc721Message(erc721OnMainChain, to, tokenId);\n        }\n        emit ERC721TokenReady(chainHash, erc721OnMainChain, tokenId);\n    }\n\n    /**\n     * @dev Adds an ERC721 token to DepositBoxERC721.\n     * \n     * Emits an {ERC721TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC721ForSchain(bytes32 chainHash, address erc721OnMainChain) internal {\n        require(erc721OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC721[chainHash].contains(erc721OnMainChain), \"ERC721 Token was already added\");\n        _schainToERC721[chainHash].add(erc721OnMainChain);\n        emit ERC721TokenAdded(chainHash, erc721OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        virtual\n    {\n        bool isMainChainToken;\n        ERC721OnChain contractOnSchain = clonesErc721[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC721OnChain(contractOnMainChain);\n            require(!addedClones[contractOnSchain], \"Incorrect main chain token\");\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.getApproved(tokenId) == address(this), \"Not allowed ERC721 Token\");\n        bytes memory data = Messages.encodeTransferErc721Message(contractOnMainChain, to, tokenId);\n        if (isMainChainToken) {\n            require(chainHash != MAINNET_HASH, \"Main chain token could not be transfered to Mainnet\");\n            data = _receiveERC721(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                tokenId\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), tokenId);\n            contractOnSchain.transferFrom(msg.sender, address(this), tokenId);\n        } else {\n            contractOnSchain.transferFrom(msg.sender, address(this), tokenId);\n            contractOnSchain.burn(tokenId);\n        }\n        messageProxy.postOutgoingMessage(chainHash, messageReceiver, data);\n    }\n\n    /**\n     * @dev Saves the ids of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc721Token, uint256 tokenId) internal {\n        require(transferredAmount[erc721Token][tokenId] == bytes32(0), \"Token was already transferred to chain\");\n        transferredAmount[erc721Token][tokenId] = chainHash;\n    }\n\n    /**\n     * @dev Returns info about ERC721 token such as token name, symbol.\n     */\n    function _getTokenInfo(IERC721MetadataUpgradeable erc721) internal view returns (Messages.Erc721TokenInfo memory) {\n        return Messages.Erc721TokenInfo({\n            name: erc721.name(),\n            symbol: erc721.symbol()\n        });\n    }\n\n    function _isERC721AddedToSchain(bytes32 chainHash, address erc721OnMainChain) internal view returns (bool) {\n        return _schainToERC721[chainHash].contains(erc721OnMainChain);\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC721.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerERC721 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./ITokenContractManager.sol\";\n\ninterface ITokenManagerERC721 is ITokenContractManager {\n    function exitToMainERC721(address contractOnMainnet, uint256 tokenId) external;\n    function transferToSchainERC721(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 tokenId\n    ) external;\n    function addERC721TokenByOwner(\n        string calldata targetChainName,\n        address erc721OnMainnet,\n        address erc721OnSchain\n    ) external;\n}"
            },
            "contracts/Messages.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
            },
            "contracts/schain/TokenManager.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/schain/ITokenManager.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/ICommunityLocker.sol\";\n\nimport \"./MessageProxyForSchain.sol\";\nimport \"./TokenManagerLinker.sol\";\nimport \"./CommunityLocker.sol\";\n\n\n/**\n * @title TokenManager\n * @dev Base contract for all token managers.\n * \n * Runs on SKALE Chains, accepts messages from mainnet, creates clones of tokens.\n * TokenManager mints tokens when user locks tokens on mainnet and burn them when user exits.\n */\nabstract contract TokenManager is AccessControlEnumerableUpgradeable, ITokenManager {\n\n    /**\n     * @dev Mainnet identifier.\n     */\n    string constant public MAINNET_NAME = \"Mainnet\";\n\n    /**\n     * @dev Keccak256 hash of mainnet name.\n     */\n    bytes32 constant public MAINNET_HASH = keccak256(abi.encodePacked(MAINNET_NAME));\n\n    /**\n     * @dev id of a role that allows turning on and turning off of automatic token clones deployment.\n     */\n    bytes32 public constant AUTOMATIC_DEPLOY_ROLE = keccak256(\"AUTOMATIC_DEPLOY_ROLE\");\n\n    /**\n     * @dev id of a role that allows to register deployed token clone.\n     */\n    bytes32 public constant TOKEN_REGISTRAR_ROLE = keccak256(\"TOKEN_REGISTRAR_ROLE\");\n    \n    /**\n     * @dev Address of MessageProxyForSchain.\n     */\n    IMessageProxyForSchain public messageProxy;\n\n    /**\n     * @dev Address of TokenManagerLinker.\n     */\n    ITokenManagerLinker public tokenManagerLinker;\n\n    /**\n     * @dev Address of CommunityLocker.\n     */\n    ICommunityLocker public communityLocker;\n\n    /**\n     * @dev Keccak256 hash of schain name.\n     */\n    bytes32 public schainHash;\n\n    /**\n     * @dev Address of corresponding deposit box on mainnet.\n     */\n    address public depositBox;\n\n    /**\n     * @dev Show if automatic deploy of token clones are allowed.\n     */\n    bool public automaticDeploy;\n\n    /**\n     * @dev Addresses of corresponding token manager on other SKALE chains.\n     */\n    //   schainHash => TokenManager\n    mapping(bytes32 => address) public tokenManagers;    \n\n    /**\n     * @dev Emitted when deposit box address was changed.\n     */\n    event DepositBoxWasChanged(\n        address oldValue,\n        address newValue\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {AUTOMATIC_DEPLOY_ROLE}.\n     */\n    modifier onlyAutomaticDeploy() {\n        require(hasRole(AUTOMATIC_DEPLOY_ROLE, msg.sender), \"AUTOMATIC_DEPLOY_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {TOKEN_REGISTRAR_ROLE}.\n     */\n    modifier onlyTokenRegistrar() {\n        require(hasRole(TOKEN_REGISTRAR_ROLE, msg.sender), \"TOKEN_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is {MessageProxy}.\n     */\n    modifier onlyMessageProxy() {\n        require(msg.sender == address(messageProxy), \"Sender is not a MessageProxy\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if\n     * a message does not aim mainnet, target SKALE chain has token manager and receiver is set.\n     */\n    modifier rightTransaction(string memory targetSchainName, address to) {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(\n            targetSchainHash != MAINNET_HASH,\n            \"This function is not for transferring to Mainnet\"\n        );\n        require(to != address(0), \"Incorrect receiver address\");\n        require(tokenManagers[targetSchainHash] != address(0), \"Incorrect Token Manager address\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if\n     * sender is deposit box on mainnet or token manager on other SKALE chain.\n     */\n    modifier checkReceiverChain(bytes32 fromChainHash, address sender) {\n        require(fromChainHash != schainHash && _checkSender(fromChainHash, sender), \"Receiver chain is incorrect\");\n        _;\n    }\n\n\n    /**\n     * @dev Turn on automatic deploy on schain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {AUTOMATIC_DEPLOY_ROLE}.\n     */\n    function enableAutomaticDeploy() external override onlyAutomaticDeploy {\n        automaticDeploy = true;\n    }\n\n    /**\n     * @dev Turn off automatic deploy on schain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {AUTOMATIC_DEPLOY_ROLE}.\n     */\n    function disableAutomaticDeploy() external onlyAutomaticDeploy {\n        automaticDeploy = false;\n    }\n\n    /**\n     * @dev Adds a TokenManager on SKALE chain to this TokenManager.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner or {TokenManagerLinker} contract.\n     * - SKALE chain must not already be added.\n     * - TokenManager address must be non-zero.\n     */\n    function addTokenManager(string calldata schainName, address newTokenManager) external override {\n        require(\n            msg.sender == address(tokenManagerLinker) ||\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\"\n        );\n        bytes32 newSchainHash = keccak256(abi.encodePacked(schainName));\n        require(tokenManagers[newSchainHash] == address(0), \"Token Manager is already set\");\n        require(newTokenManager != address(0), \"Incorrect Token Manager address\");\n        tokenManagers[newSchainHash] = newTokenManager;\n    }\n\n    /**\n     * @dev Remove a TokenManager on SKALE chain from TokenManager.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner or {TokenManagerLinker} contract.\n     * - SKALE chain must already be set.\n     */\n    function removeTokenManager(string calldata schainName) external override {\n        require(\n            msg.sender == address(tokenManagerLinker) ||\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\"\n        );\n        bytes32 newSchainHash = keccak256(abi.encodePacked(schainName));\n        require(tokenManagers[newSchainHash] != address(0), \"Token Manager is not set\");\n        delete tokenManagers[newSchainHash];\n    }\n\n    /**\n     * @dev Change Deposit Box address\n     * This function should be executed only in emergency.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner.\n     * - {newDepositBox} must be set.\n     */\n    function changeDepositBoxAddress(address newDepositBox) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        require(newDepositBox != address(0), \"DepositBox address has to be set\");\n        emit DepositBoxWasChanged(depositBox, newDepositBox);\n        depositBox = newDepositBox;\n    }\n\n    /**\n     * @dev Checks whether TokenManager is connected to a {schainName} SKALE chain TokenManager.\n     */\n    function hasTokenManager(string calldata schainName) external view override returns (bool) {\n        return tokenManagers[keccak256(abi.encodePacked(schainName))] != address(0);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initializeTokenManager(\n        string memory newSchainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        public\n        virtual\n        initializer\n    {\n        require(newDepositBox != address(0), \"DepositBox address has to be set\");\n\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(AUTOMATIC_DEPLOY_ROLE, msg.sender);\n        _setupRole(TOKEN_REGISTRAR_ROLE, msg.sender);\n\n        schainHash = keccak256(abi.encodePacked(newSchainName));\n        messageProxy = newMessageProxy;\n        tokenManagerLinker = newIMALinker;\n        communityLocker = newCommunityLocker;        \n        depositBox = newDepositBox;\n\n        emit DepositBoxWasChanged(address(0), newDepositBox);\n    }\n\n    /**\n     * @dev Checks whether sender contract is DepositBox or TokenManager depending on chainHash.\n     */\n    function _checkSender(bytes32 fromChainHash, address sender) internal view virtual returns (bool) {\n        return fromChainHash == MAINNET_HASH ? sender == depositBox : sender == tokenManagers[fromChainHash];\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenContractManager.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerERC20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../ICommunityLocker.sol\";\nimport \"../IMessageProxyForSchain.sol\";\nimport \"../ITokenManager.sol\";\nimport \"../ITokenManagerLinker.sol\";\n\ninterface ITokenContractManager is ITokenManager {\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    ) external;\n}"
            },
            "@skalenetwork/ima-interfaces/schain/ICommunityLocker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ICommunityLocker.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IMessageReceiver.sol\";\n\nimport \"./IMessageProxyForSchain.sol\";\nimport \"./ITokenManagerLinker.sol\";\n\n\ninterface ICommunityLocker is IMessageReceiver {\n    function initialize(\n        string memory newSchainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newTokenManagerLinker,\n        address newCommunityPool\n    ) external;\n    function checkAllowedToSendMessage(bytes32 chainHash, address receiver) external;\n    function setTimeLimitPerMessage(string memory chainName, uint newTimeLimitPerMessage) external;\n    function setGasPrice(uint gasPrice, uint timestamp, IMessageProxyForSchain.Signature memory signature) external;\n}"
            },
            "@skalenetwork/ima-interfaces/schain/IMessageProxyForSchain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IMessageProxyForSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IMessageProxy.sol\";\nimport \"./IKeyStorage.sol\";\n\ninterface IMessageProxyForSchain is IMessageProxy {\n    struct OutgoingMessageData {\n        bytes32 dstChainHash; // destination chain\n        uint256 msgCounter; // message counter\n        address srcContract; // origin\n        address dstContract; // receiver\n        bytes data; // payload\n    }\n\n    function initialize(IKeyStorage blsKeyStorage, string memory schainName) external;\n    function verifyOutgoingMessageData(OutgoingMessageData memory message) external view returns (bool);\n    function verifySignature(bytes32 hashedMessage, Signature memory signature) external view returns (bool);\n    function messageInProgress() external view returns (bool);\n}"
            },
            "@skalenetwork/ima-interfaces/schain/ITokenManager.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManager - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IMessageReceiver.sol\";\n\n\ninterface ITokenManager is IMessageReceiver {\n    function enableAutomaticDeploy() external;\n    function addTokenManager(string calldata schainName, address newTokenManager) external;\n    function removeTokenManager(string calldata schainName) external;\n    function hasTokenManager(string calldata schainName) external view returns (bool);\n}"
            },
            "@skalenetwork/ima-interfaces/schain/ITokenManagerLinker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerLinker - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./IMessageProxyForSchain.sol\";\nimport \"./ITokenManager.sol\";\n\n\ninterface ITokenManagerLinker {\n    function initialize(IMessageProxyForSchain newMessageProxyAddress, address linker) external;\n    function registerTokenManager(ITokenManager newTokenManager) external;\n    function removeTokenManager(ITokenManager tokenManagerAddress) external;\n    function connectSchain(string calldata schainName) external;\n    function disconnectSchain(string calldata schainName) external;\n    function hasTokenManager(ITokenManager tokenManager) external view returns (bool);\n    function hasSchain(string calldata schainName) external view returns (bool connected);\n}"
            },
            "@skalenetwork/ima-interfaces/schain/IKeyStorage.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IKeyStorage.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./bls/IFieldOperations.sol\";\n\n\ninterface IKeyStorage {\n    function initialize() external;\n    function getBlsCommonPublicKey() external view returns (IFieldOperations.G2Point memory);\n}"
            },
            "@skalenetwork/ima-interfaces/schain/bls/IFieldOperations.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IFieldOperations.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IFieldOperations {\n\n    /**\n     * @dev Structure that represents the field element { a + ib }\n     */\n    struct Fp2Point {\n        uint a;\n        uint b;\n    }\n\n    /**\n     * @dev Structure that represents an element of G2\n     */\n    struct G2Point {\n        Fp2Point x;\n        Fp2Point y;\n    }\n}"
            },
            "contracts/schain/MessageProxyForSchain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/IMessageProxyForSchain.sol\";\nimport \"@skalenetwork/etherbase-interfaces/IEtherbaseUpgradeable.sol\";\n\nimport \"../MessageProxy.sol\";\nimport \"./bls/SkaleVerifier.sol\";\n\n\n/**\n * @title MessageProxyForSchain\n * @dev Entry point for messages that come from mainnet or other SKALE chains\n * and contract that emits messages for mainnet or other SKALE chains.\n * \n * Messages are submitted by IMA-agent and secured with threshold signature.\n * \n * IMA-agent monitors events of {MessageProxyForSchain} and sends messages to other chains.\n\n * NOTE: 16 Agents\n * Synchronize time with time.nist.gov\n * Every agent checks if it is their time slot\n * Time slots are in increments of 5 minutes\n * At the start of their slot each agent:\n * For each connected schain:\n * Read incoming counter on the dst chain\n * Read outgoing counter on the src chain\n * Calculate the difference outgoing - incoming\n * Call postIncomingMessages function passing (un)signed message array\n * ID of this schain, Chain 0 represents ETH mainnet,\n */\ncontract MessageProxyForSchain is MessageProxy, IMessageProxyForSchain {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    IEtherbaseUpgradeable public constant ETHERBASE = IEtherbaseUpgradeable(\n        payable(0xd2bA3e0000000000000000000000000000000000)\n    );\n    uint public constant MINIMUM_BALANCE = 1 ether;\n\n    /**\n     * @dev Structure that contains information about outgoing message.\n     */\n\n    /**\n     * @dev Address of {KeyStorage}.\n     */\n    IKeyStorage public keyStorage;\n\n    /**\n     * @dev Keccak256 hash of schain name.\n     */\n    bytes32 public schainHash;\n\n    /**\n     * @dev Hashed of meta information of outgoing messages.\n     */\n    //      schainHash  =>      message_id  => MessageData\n    mapping(bytes32 => mapping(uint256 => bytes32)) private _outgoingMessageDataHash;\n\n    /**\n     * @dev First unprocessed outgoing message.\n     */\n    //      schainHash  => head of unprocessed messages\n    mapping(bytes32 => uint) private _idxHead;\n\n    /**\n     * @dev Last unprocessed outgoing message.\n     */\n    //      schainHash  => tail of unprocessed messages\n    mapping(bytes32 => uint) private _idxTail;\n\n    // disable detector until slither will fix this issue\n    // https://github.com/crytic/slither/issues/456\n    // slither-disable-next-line uninitialized-state\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _registryContracts;\n\n    string public version;\n    bool public override messageInProgress;\n\n    /**\n     * @dev Reentrancy guard for postIncomingMessages.\n     */\n    modifier messageInProgressLocker() {\n        require(!messageInProgress, \"Message is in progress\");\n        messageInProgress = true;\n        _;\n        messageInProgress = false;\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     * - Destination chain hash cannot be equal to itself\n     */\n    function registerExtraContract(\n        string memory chainName,\n        address extraContract\n    )\n        external\n        override\n        onlyExtraContractRegistrar\n    {\n        bytes32 chainHash = keccak256(abi.encodePacked(chainName));\n        require(chainHash != schainHash, \"Destination chain hash cannot be equal to itself\");\n        _registerExtraContract(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from chain to chain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     * - Destination chain hash cannot be equal to itself\n     */\n    function removeExtraContract(\n        string memory chainName,\n        address extraContract\n    )\n        external\n        override\n        onlyExtraContractRegistrar\n    {\n        bytes32 chainHash = keccak256(abi.encodePacked(chainName));\n        require(chainHash != schainHash, \"Destination chain hash cannot be equal to itself\");\n        _removeExtraContract(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Link external chain.\n     *\n     * NOTE: Mainnet is linked automatically.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {CHAIN_CONNECTOR_ROLE}.\n     * - Target chain must be different from the current.\n     */\n    function addConnectedChain(string calldata chainName) external override {\n        bytes32 chainHash = keccak256(abi.encodePacked(chainName));\n        require(chainHash != schainHash, \"Schain cannot connect itself\");\n        _addConnectedChain(chainHash);\n    }    \n\n    /**\n     * @dev Entry point for incoming messages.\n     * This function is called by IMA-agent to deliver incoming messages from external chains.\n     * \n     * Requirements:\n     * \n     * - Origin chain has to be registered.\n     * - Amount of messages must be no more than {MESSAGES_LENGTH}.\n     * - Messages batch has to be signed with threshold signature.\n     * by super majority of current SKALE chain nodes.\n     * - All previous messages must be already delivered.\n     */\n    function postIncomingMessages(\n        string calldata fromChainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata signature \n    )\n        external\n        override(IMessageProxy, MessageProxy)\n        messageInProgressLocker\n    {\n        bytes32 fromChainHash = keccak256(abi.encodePacked(fromChainName));\n        require(connectedChains[fromChainHash].inited, \"Chain is not initialized\");\n        require(messages.length <= MESSAGES_LENGTH, \"Too many messages\");\n        require(_verifyMessages(\n            _hashedArray(messages, startingCounter, fromChainName), signature),\n            \"Signature is not verified\");\n        require(\n            startingCounter == connectedChains[fromChainHash].incomingMessageCounter,\n            \"Starting counter is not qual to incoming message counter\");\n        connectedChains[fromChainHash].incomingMessageCounter += messages.length;\n        for (uint256 i = 0; i < messages.length; i++) {\n            _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);\n        }\n        _topUpBalance();\n    }\n\n    /**\n     * @dev Sets new version of contracts on schain\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted DEFAULT_ADMIN_ROLE.\n     */\n    function setVersion(string calldata newVersion) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        emit VersionUpdated(version, newVersion);\n        version = newVersion;\n    }\n\n    /**\n     * @dev Verify if the message metadata is valid.\n     */\n    function verifyOutgoingMessageData(\n        OutgoingMessageData memory message\n    )\n        external\n        view\n        override\n        returns (bool isValidMessage)\n    {\n        bytes32 messageDataHash = _outgoingMessageDataHash[message.dstChainHash][message.msgCounter];\n        if (messageDataHash == _hashOfMessage(message))\n            isValidMessage = true;\n    }\n\n    /**\n     * @dev Verify signature of hashed message\n     */\n    function verifySignature(bytes32 hashedMessage, MessageProxyForSchain.Signature calldata signature)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _verifyMessages(hashedMessage, signature);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(IKeyStorage blsKeyStorage, string memory schainName)\n        public\n        override\n        virtual\n        initializer\n    {\n        MessageProxy.initializeMessageProxy(3e6);\n        keyStorage = blsKeyStorage;\n        connectedChains[\n            MAINNET_HASH\n        ] = ConnectedChainInfo(\n            0,\n            0,\n            true,\n            0\n        );\n\t    schainHash = keccak256(abi.encodePacked(schainName));\n\n        // In predeployed mode all token managers and community locker\n        // will be added to registryContracts\n    }\n\n    /**\n     * @dev Unlink external SKALE chain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {CHAIN_CONNECTOR_ROLE}.\n     * - Target chain must be different from Mainnet.\n     */\n    function removeConnectedChain(\n        string memory chainName\n    )\n        public\n        override(IMessageProxy, MessageProxy)\n        onlyChainConnector\n    {\n        bytes32 chainHash = keccak256(abi.encodePacked(chainName));\n        require(chainHash != MAINNET_HASH, \"Mainnet cannot be removed\");\n        super.removeConnectedChain(chainName);\n    }\n\n    /**\n     * @dev This function is called by a smart contract\n     * that wants to make a cross-chain call.\n     * \n     * Requirements:\n     * \n     * - Destination chain has to be registered.\n     * - Sender contract has to be registered.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override(IMessageProxy, MessageProxy)\n    {\n        super.postOutgoingMessage(targetChainHash, targetContract, data);\n\n        OutgoingMessageData memory outgoingMessageData = OutgoingMessageData(\n            targetChainHash,\n            connectedChains[targetChainHash].outgoingMessageCounter - 1,\n            msg.sender,\n            targetContract,\n            data\n        );\n\n        bytes32 dstChainHash = outgoingMessageData.dstChainHash;\n        _outgoingMessageDataHash[dstChainHash][_idxTail[dstChainHash]] = _hashOfMessage(outgoingMessageData);\n        _idxTail[dstChainHash] += 1;\n    }\n\n    // private\n\n    /**\n     * @dev Converts calldata structure to memory structure and checks\n     * whether message BLS signature is valid.\n     * Returns true if signature is valid.\n     */\n    function _verifyMessages(\n        bytes32 hashedMessages,\n        MessageProxyForSchain.Signature calldata signature\n    )\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return SkaleVerifier.verify(\n            IFieldOperations.Fp2Point({\n                a: signature.blsSignature[0],\n                b: signature.blsSignature[1]\n            }),\n            hashedMessages,\n            signature.counter,\n            signature.hashA,\n            signature.hashB,\n            keyStorage.getBlsCommonPublicKey()\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        override\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage)\n    {\n        return _registryContracts;\n    }\n\n    /**\n     * @dev Returns Etherbase contract\n     */\n    function _getEtherbase() internal view virtual returns (IEtherbaseUpgradeable) {\n        return ETHERBASE;\n    }\n\n    /**\n     * @dev Move skETH from Etherbase if the balance is too low\n     */\n    function _topUpBalance() private {\n        uint balance = msg.sender.balance + gasleft() * tx.gasprice;\n        IEtherbaseUpgradeable etherbase = _getEtherbase();\n        if (address(etherbase).isContract()\n            && etherbase.hasRole(etherbase.ETHER_MANAGER_ROLE(), address(this)) \n            && balance < MINIMUM_BALANCE\n        ) {\n            uint missingAmount = MINIMUM_BALANCE - balance;\n            if (missingAmount < address(etherbase).balance) {\n                etherbase.partiallyRetrieve(payable(msg.sender), missingAmount);\n            } else {\n                etherbase.retrieve(payable(msg.sender));\n            }\n        }\n    }\n\n    /**\n     * @dev Calculate a message hash.\n     */\n    function _hashOfMessage(OutgoingMessageData memory message) private pure returns (bytes32) {\n        bytes memory data = abi.encodePacked(\n            message.dstChainHash,\n            bytes32(message.msgCounter),\n            bytes32(bytes20(message.srcContract)),\n            bytes32(bytes20(message.dstContract)),\n            message.data\n        );\n        return keccak256(data);\n    }    \n}\n"
            },
            "contracts/schain/TokenManagerLinker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IMALinkerSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/ITokenManagerLinker.sol\";\n\nimport \"../Messages.sol\";\nimport \"../MessageProxy.sol\";\nimport \"./TokenManager.sol\";\n\n\n/**\n * @title TokenManagerLinker\n * @dev Links custom TokenManagers to MessageProxy.\n */\ncontract TokenManagerLinker is ITokenManagerLinker, AccessControlEnumerableUpgradeable {\n\n    /**\n     * @dev Mainnet identifier.\n     */\n    string constant public MAINNET_NAME = \"Mainnet\";\n\n     /**\n     * @dev Keccak256 hash of mainnet name.\n     */\n    bytes32 constant public MAINNET_HASH = keccak256(abi.encodePacked(MAINNET_NAME));\n\n    /**\n     * @dev id of a role that allows to register new token manager.\n     */\n    bytes32 public constant REGISTRAR_ROLE = keccak256(\"REGISTRAR_ROLE\");\n\n    /**\n     * @dev Address of MessageProxyForSchain.\n     */\n    IMessageProxyForSchain public messageProxy;\n\n    /**\n     * @dev Address of {Linker} on mainnet.\n     */\n    address public linkerAddress;\n\n    /**\n     * @dev List of address of registered token managers.\n     */\n    ITokenManager[] public tokenManagers;\n\n    // Deprecated variable\n    bool private _interchainConnections;\n    //\n\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {REGISTRAR_ROLE}.\n     */\n    modifier onlyRegistrar() {\n        require(hasRole(REGISTRAR_ROLE, msg.sender), \"REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Register new token manager.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {REGISTRAR_ROLE}.\n     */\n    function initialize(IMessageProxyForSchain newMessageProxyAddress, address linker)\n        external\n        override\n        initializer\n    {\n        require(linker != address(0), \"Linker address has to be set\");\n\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(REGISTRAR_ROLE, msg.sender);\n        messageProxy = newMessageProxyAddress;    \n\t    linkerAddress = linker;\n\n        // fake usage of variable\n        delete _interchainConnections;\n    }  \n\n    /**\n     * @dev Adds new TokenManager.\n     */\n    function registerTokenManager(ITokenManager newTokenManager) external override onlyRegistrar {\n        tokenManagers.push(newTokenManager);\n    }\n\n    /**\n     * @dev Cancel registration of token manager.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {REGISTRAR_ROLE}.\n     */\n    function removeTokenManager(ITokenManager tokenManagerAddress) external override onlyRegistrar {\n        uint index;\n        uint length = tokenManagers.length;\n        for (index = 0; index < length; index++) {\n            if (tokenManagers[index] == tokenManagerAddress) {\n                break;\n            }\n        }\n        if (index < length) {\n            if (index < length - 1) {\n                tokenManagers[index] = tokenManagers[length - 1];\n            }\n            tokenManagers.pop();\n        }\n    }\n\n    /**\n     * @dev Register new SKALE chain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {REGISTRAR_ROLE}.\n     * - Direct messaging between SKALE chains must be allowed.\n     * - Amount of token managers on target SKALE chain must be equal to the amount on current one.\n     */\n    function connectSchain(\n        string calldata schainName\n    )\n        external\n        override\n        onlyRegistrar\n    {\n        for (uint i = 0; i < tokenManagers.length; i++) {\n            tokenManagers[i].addTokenManager(schainName, address(tokenManagers[i]));\n        }\n        messageProxy.addConnectedChain(schainName);\n    }\n\n    /**\n     * @dev Cancel registration of linked SKALE chain.\n     * \n     * Requirements:\n     * \n     * - Function caller has to be granted with {REGISTRAR_ROLE}.\n     */\n    function disconnectSchain(string calldata schainName) external override onlyRegistrar {\n        uint length = tokenManagers.length;\n        for (uint i = 0; i < length; i++) {\n            tokenManagers[i].removeTokenManager(schainName);\n        }\n        messageProxy.removeConnectedChain(schainName);\n    }\n\n    /**\n     * @dev Check if {tokenManager} is registered in IMA.\n     */\n    function hasTokenManager(ITokenManager tokenManager) external view override returns (bool) {\n        uint index;\n        uint length = tokenManagers.length;\n        for (index = 0; index < length; index++) {\n            if (tokenManagers[index] == tokenManager) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Check if SKALE chain with name {schainName} is registered in IMA.\n     */\n    function hasSchain(string calldata schainName) external view override returns (bool connected) {\n        uint length = tokenManagers.length;\n        connected = true;\n        for (uint i = 0; i < length; i++) {\n            connected = connected && tokenManagers[i].hasTokenManager(schainName);\n        }\n        connected = connected && messageProxy.isConnectedChain(schainName);\n    }\n}\n"
            },
            "contracts/schain/CommunityLocker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    CommunityLocker.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n    @author Artem Payvin\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/ICommunityLocker.sol\";\n\nimport \"../Messages.sol\";\n\ninterface ICommunityLockerInitializer is ICommunityLocker {\n    function initializeTimestamp() external;\n}\n\n\n/**\n * @title CommunityLocker\n * @dev Contract contains logic to perform automatic reimbursement\n * of gas fees for sent messages\n */\ncontract CommunityLocker is ICommunityLockerInitializer, AccessControlEnumerableUpgradeable {\n\n    /**\n     * @dev Mainnet identifier.\n     */\n    string constant public MAINNET_NAME = \"Mainnet\";\n\n    /**\n     * @dev Keccak256 hash of mainnet name.\n     */\n    bytes32 constant public MAINNET_HASH = keccak256(abi.encodePacked(MAINNET_NAME));\n\n    /**\n     * @dev id of a role that allows changing of the contract parameters.\n     */\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n\n    /**\n     * @dev Address of MessageProxyForSchain.\n     */\n    IMessageProxyForSchain public messageProxy;\n\n    /**\n     * @dev Address of TokenManagerLinker.\n     */\n    ITokenManagerLinker public tokenManagerLinker;\n\n    /**\n     * @dev Address of CommunityPool on mainnet.\n     */\n    address public communityPool;\n\n    /**\n     * @dev Keccak256 hash of schain name.\n     */\n    bytes32 public schainHash;\n\n    // Disable slither check due to variable depreciation\n    // and unavailability of making it constant because\n    // it breaks upgradeability pattern.\n    // slither-disable-next-line constable-states\n    uint private _deprecatedTimeLimitPerMessage;\n\n    /**\n     * @dev Mapping of users who are allowed to send a message.\n     */\n    // user address => allowed to send message\n    mapping(address => bool) public activeUsers;\n\n    /**\n     * @dev Timestamp of previous sent message by user.\n     */\n    // user address => timestamp of last message\n    mapping(address => uint) public lastMessageTimeStamp;\n\n    /**\n     * @dev mainnet gas price(baseFee) value\n     */\n    uint256 public mainnetGasPrice;\n\n    /**\n     * @dev Timestamp of previous set of mainnet gas price\n     */\n    uint256 public gasPriceTimestamp;\n\n    /**\n     * @dev Amount of seconds after message sending\n     * when next message cannot be sent.\n     */\n    // schainHash   => time limit\n    mapping(bytes32 => uint) public timeLimitPerMessage;\n\n    /**\n     * @dev Timestamp of previous sent message by user during\n     * schain to schain transfers\n     */\n    // schainHash   =>           user  => timestamp\n    mapping(bytes32 => mapping(address => uint)) public lastMessageTimeStampToSchain;\n\n    /**\n     * @dev Emitted when a user becomes active.\n     */\n    event ActivateUser(\n        bytes32 schainHash,\n        address user\n    );\n\n    /**\n     * @dev Emitted when a user stops being active.\n     */\n    event LockUser(\n        bytes32 schainHash,\n        address user\n    ); \n\n    /**\n     * @dev Emitted when constants updated.\n     */\n    event ConstantUpdated(\n        bytes32 indexed constantHash,\n        uint previousValue,\n        uint newValue\n    );\n\n    modifier checkUserBeforeTransfer(bytes32 chainHash, address user) {\n        uint256 lastTimestamp = lastMessageTimeStampToSchain[chainHash][user];\n        if (chainHash == MAINNET_HASH) {\n            require(activeUsers[user], \"Recipient must be active\");\n            lastTimestamp = lastMessageTimeStamp[user];\n        }\n        require(\n            lastTimestamp + timeLimitPerMessage[chainHash] < block.timestamp,\n            \"Exceeded message rate limit\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the caller of the function.\n     * - CommunityPool must be an origin of the message on mainnet.\n     * - The message must come from the mainnet.\n     * - The message must contains status of a user.\n     * - Status of a user in the message must be different from the current status.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n    {\n        require(msg.sender == address(messageProxy), \"Sender is not a message proxy\");\n        require(sender == communityPool, \"Sender must be CommunityPool\");\n        require(fromChainHash == MAINNET_HASH, \"Source chain name must be Mainnet\");\n        Messages.MessageType operation = Messages.getMessageType(data);\n        require(operation == Messages.MessageType.USER_STATUS, \"The message should contain a status of user\");\n        Messages.UserStatusMessage memory message = Messages.decodeUserStatusMessage(data);\n        require(activeUsers[message.receiver] != message.isActive, \"Active user statuses must be different\");\n        activeUsers[message.receiver] = message.isActive;\n        if (message.isActive) {\n            emit ActivateUser(schainHash, message.receiver);\n        } else {\n            emit LockUser(schainHash, message.receiver);\n        }\n    }\n\n    /**\n     * @dev Reverts if {receiver} is not allowed to send a message.\n     *\n     * Requirements:\n     * \n     * - Function caller has to be registered in TokenManagerLinker as a TokenManager.\n     * - {receiver} must be an active user.\n     * - Previous message sent by {receiver} must be sent earlier then {timeLimitPerMessage} seconds before current time\n     * or there are no messages sent by {receiver}.\n     */\n    function checkAllowedToSendMessage(bytes32 chainHash, address receiver)\n        external\n        checkUserBeforeTransfer(chainHash, receiver)\n        override\n    {\n        require(\n            tokenManagerLinker.hasTokenManager(ITokenManager(msg.sender)),\n            \"Sender is not registered token manager\"\n        );\n        if (chainHash == MAINNET_HASH) {\n            lastMessageTimeStamp[receiver] = block.timestamp;\n        } else {\n            lastMessageTimeStampToSchain[chainHash][receiver] = block.timestamp;\n        }\n    }\n\n    /**\n     * @dev Set value of {timeLimitPerMessage} of given chain.\n     *\n     * Requirements:\n     * \n     * - Function caller has to be granted with {CONSTANT_SETTER_ROLE}.\n     * \n     * Emits a {ConstantUpdated} event.\n     */\n    function setTimeLimitPerMessage(string memory chainName, uint newTimeLimitPerMessage) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        bytes32 chainHash = keccak256(abi.encodePacked(chainName));\n        require(chainHash != schainHash, \"Incorrect chain\");\n        emit ConstantUpdated(\n            keccak256(abi.encodePacked(\"TimeLimitPerMessage\")),\n            timeLimitPerMessage[chainHash],\n            newTimeLimitPerMessage\n        );\n        timeLimitPerMessage[chainHash] = newTimeLimitPerMessage;\n    }\n\n    /**\n     * @dev Set value of {mainnetGasPrice}.\n     *\n     * Requirements:\n     * \n     * - Signature should be verified.\n     * \n     * Emits a {ConstantUpdated} event.\n     */\n    function setGasPrice(\n        uint gasPrice,\n        uint timestamp,\n        IMessageProxyForSchain.Signature memory\n    )\n        external\n        override\n    {\n        require(timestamp > gasPriceTimestamp, \"Gas price timestamp already updated\");\n        require(timestamp <= block.timestamp, \"Timestamp should not be in the future\");\n        // TODO: uncomment when oracle finished\n        // require(\n        //     messageProxy.verifySignature(keccak256(abi.encodePacked(gasPrice, timestamp)), signature),\n        //     \"Signature is not verified\"\n        // );\n        emit ConstantUpdated(\n            keccak256(abi.encodePacked(\"MainnetGasPrice\")),\n            mainnetGasPrice,\n            gasPrice\n        );\n        mainnetGasPrice = gasPrice;\n        gasPriceTimestamp = timestamp;\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newSchainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newTokenManagerLinker,\n        address newCommunityPool\n    )\n        external\n        override\n        initializer\n    {\n        require(newCommunityPool != address(0), \"Node address has to be set\");\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        messageProxy = newMessageProxy;\n        tokenManagerLinker = newTokenManagerLinker;\n        schainHash = keccak256(abi.encodePacked(newSchainName));\n        timeLimitPerMessage[MAINNET_HASH] = 5 minutes;\n        communityPool = newCommunityPool;\n    }\n\n    /**\n     * @dev Initialize timestamp after upgrade and should be removed after upgrade\n     *\n     * Requirements:\n     * Should be called only by address which hold DEFAULT_ADMIN_ROLE role\n     */\n    function initializeTimestamp() external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Incorrect sender\");\n        // Disable slither check due to moving data to the new data structure\n        // slither-disable-next-line uninitialized-state\n        timeLimitPerMessage[MAINNET_HASH] = _deprecatedTimeLimitPerMessage;\n        delete _deprecatedTimeLimitPerMessage;\n    }\n}\n"
            },
            "@skalenetwork/etherbase-interfaces/IEtherbaseUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEtherbaseUpgradeable.sol - Etherbase\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   Etherbase is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   Etherbase is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with Etherbase.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\n\nimport \"./IEtherbase.sol\";\n\ninterface IEtherbaseUpgradeable is IAccessControlUpgradeable, IEtherbase {\n    function initialize(address schainOwner) external;\n    // slither-disable-next-line naming-convention\n    function ETHER_MANAGER_ROLE() external pure returns (bytes32); // solhint-disable-line func-name-mixedcase\n}"
            },
            "contracts/schain/bls/SkaleVerifier.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    SkaleVerifier.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\nimport \"./Precompiled.sol\";\nimport \"./FieldOperations.sol\";\n\n/**\n * @title SkaleVerifier\n * @dev Contains verify function to perform BLS signature verification.\n */\nlibrary SkaleVerifier {\n    using Fp2Operations for IFieldOperations.Fp2Point;\n\n\n    /**\n    * @dev Verifies a BLS signature.\n    * \n    * Requirements:\n    * \n    * - Signature is in G1.\n    * - Hash is in G1.\n    * - G2.one in G2.\n    * - Public Key in G2.\n    */\n    function verify(\n        IFieldOperations.Fp2Point memory signature,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        IFieldOperations.G2Point memory publicKey\n    )\n        internal\n        view\n        returns (bool)\n    {\n        require(G1Operations.checkRange(signature), \"Signature is not valid\");\n        if (!_checkHashToGroupWithHelper(\n            hash,\n            counter,\n            hashA,\n            hashB\n            )\n        )\n        {\n            return false;\n        }\n\n        uint newSignB = G1Operations.negate(signature.b);\n        require(G1Operations.isG1Point(signature.a, newSignB), \"Sign not in G1\");\n        require(G1Operations.isG1Point(hashA, hashB), \"Hash not in G1\");\n\n        IFieldOperations.G2Point memory g2 = G2Operations.getG2Generator();\n        require(\n            G2Operations.isG2(publicKey),\n            \"Public Key not in G2\"\n        );\n\n        return Precompiled.bn256Pairing(\n            signature.a, newSignB,\n            g2.x.b, g2.x.a, g2.y.b, g2.y.a,\n            hashA, hashB,\n            publicKey.x.b, publicKey.x.a, publicKey.y.b, publicKey.y.a\n        );\n    }\n\n    function _checkHashToGroupWithHelper(\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB\n    )\n        private\n        pure\n        returns (bool)\n    {\n        if (counter > 100) {\n            return false;\n        }\n        uint xCoordinate = uint(hash) % Fp2Operations.P;\n        xCoordinate = (xCoordinate + counter) % Fp2Operations.P;\n\n        uint ySquared = addmod(\n            mulmod(mulmod(xCoordinate, xCoordinate, Fp2Operations.P), xCoordinate, Fp2Operations.P),\n            3,\n            Fp2Operations.P\n        );\n        if (hashB < Fp2Operations.P / 2 || mulmod(hashB, hashB, Fp2Operations.P) != ySquared || xCoordinate != hashA) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"
            },
            "@skalenetwork/etherbase-interfaces/IEtherbase.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEtherbase.sol - Etherbase\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   Etherbase is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   Etherbase is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with Etherbase.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\ninterface IEtherbase {\n    receive() external payable;\n    function retrieve(address payable receiver) external;\n    function partiallyRetrieve(address payable receiver, uint amount) external;\n}"
            },
            "contracts/schain/bls/Precompiled.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    Precompiled.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\n/**\n * @title Precompiled\n * @dev This library is a wrapper to call precompiled contracts\n * \n * Defined calls:\n * \n * - bn256Pairing\n */\nlibrary Precompiled {\n\n    /**\n     * @dev Calls precompiled contract with address 0x8\n     * for elliptic curve pairing operations are required in order to perform zkSNARK verification\n     * within the block gas limit.\n     * see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md for more details\n     */\n    function bn256Pairing(\n        uint x1,\n        uint y1,\n        uint a1,\n        uint b1,\n        uint c1,\n        uint d1,\n        uint x2,\n        uint y2,\n        uint a2,\n        uint b2,\n        uint c2,\n        uint d2)\n        internal view returns (bool)\n    {\n        bool success;\n        uint[12] memory inputToPairing;\n        inputToPairing[0] = x1;\n        inputToPairing[1] = y1;\n        inputToPairing[2] = a1;\n        inputToPairing[3] = b1;\n        inputToPairing[4] = c1;\n        inputToPairing[5] = d1;\n        inputToPairing[6] = x2;\n        inputToPairing[7] = y2;\n        inputToPairing[8] = a2;\n        inputToPairing[9] = b2;\n        inputToPairing[10] = c2;\n        inputToPairing[11] = d2;\n        uint[1] memory out;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success := staticcall(not(0), 8, inputToPairing, mul(12, 0x20), out, 0x20)\n        }\n        require(success, \"Pairing check failed\");\n        return out[0] != 0;\n    }\n}"
            },
            "contracts/schain/bls/FieldOperations.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    FieldOperations.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n\n    @author Dmytro Stebaiev\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/schain/bls/IFieldOperations.sol\";\n\nimport \"./Precompiled.sol\";\n\n\n/**\n * @title Fp2Operations\n * @dev This library contains operations of field that is an extension by imaginary unit of \n * a field of division remainders of a prime number\n * \n * Element of field is Fp2Point\n * \n * Prime divisor is P\n * \n * Defined operations:\n * \n * - addition\n * - subtraction\n * - scalar multiplication\n * - multiplication\n * - squaring\n * - comparison for equality\n */\nlibrary Fp2Operations {\n\n    /**\n     * @dev Prime devisor\n     */\n    uint constant public P = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * @dev Add {value1} to {value2}\n     */\n    function addFp2(\n        IFieldOperations.Fp2Point memory value1,\n        IFieldOperations.Fp2Point memory value2\n    )\n        internal\n        pure\n        returns (IFieldOperations.Fp2Point memory)\n    {\n        return IFieldOperations.Fp2Point({ a: addmod(value1.a, value2.a, P), b: addmod(value1.b, value2.b, P) });\n    }\n\n    /**\n     * @dev Perform scalar multiplication of {value} by {scalar}\n     */\n    function scalarMulFp2(\n        IFieldOperations.Fp2Point memory value,\n        uint scalar\n    )\n        internal\n        pure\n        returns (IFieldOperations.Fp2Point memory)\n    {\n        return IFieldOperations.Fp2Point({ a: mulmod(scalar, value.a, P), b: mulmod(scalar, value.b, P) });\n    }\n\n    /**\n     * @dev Subtract {subtracted} from {diminished}\n     */\n    function minusFp2(\n        IFieldOperations.Fp2Point memory diminished,\n        IFieldOperations.Fp2Point memory subtracted\n    )\n        internal\n        pure\n        returns (IFieldOperations.Fp2Point memory difference)\n    {\n        uint p = P;\n        if (diminished.a >= subtracted.a) {\n            difference.a = addmod(diminished.a, p - subtracted.a, p);\n        } else {\n            difference.a = (p - addmod(subtracted.a, p - diminished.a, p)) % p;\n        }\n        if (diminished.b >= subtracted.b) {\n            difference.b = addmod(diminished.b, p - subtracted.b, p);\n        } else {\n            difference.b = (p - addmod(subtracted.b, p - diminished.b, p)) % p;\n        }\n    }\n\n    /**\n     * @dev Multiply {value1} by {value2}\n     */\n    function mulFp2(\n        IFieldOperations.Fp2Point memory value1,\n        IFieldOperations.Fp2Point memory value2\n    )\n        internal\n        pure\n        returns (IFieldOperations.Fp2Point memory result)\n    {\n        uint p = P;\n        IFieldOperations.Fp2Point memory point = IFieldOperations.Fp2Point({\n            a: mulmod(value1.a, value2.a, p),\n            b: mulmod(value1.b, value2.b, p)});\n        result.a = addmod(\n            point.a,\n            mulmod(p - 1, point.b, p),\n            p);\n        result.b = addmod(\n            mulmod(\n                addmod(value1.a, value1.b, p),\n                addmod(value2.a, value2.b, p),\n                p),\n            p - addmod(point.a, point.b, p),\n            p);\n    }\n\n    /**\n     * @dev Square {value}\n     */\n    function squaredFp2(\n        IFieldOperations.Fp2Point memory value\n    )\n        internal\n        pure\n        returns (IFieldOperations.Fp2Point memory)\n    {\n        uint p = P;\n        uint ab = mulmod(value.a, value.b, p);\n        uint multiplication = mulmod(addmod(value.a, value.b, p), addmod(value.a, mulmod(p - 1, value.b, p), p), p);\n        return IFieldOperations.Fp2Point({ a: multiplication, b: addmod(ab, ab, p) });\n    }\n\n    /**\n     * @dev Check if {value1} is equal to {value2}\n     */\n    function isEqual(\n        IFieldOperations.Fp2Point memory value1,\n        IFieldOperations.Fp2Point memory value2\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return value1.a == value2.a && value1.b == value2.b;\n    }\n}\n\n/**\n * @title G1Operations\n * @dev This library contains operations of a group of elements {x, y}\n * where y^2 = x^3 + 3 mod P and (x + iy) is an element of Fp2\n * \n * Element of the group is Fp2Point\n * \n * Prime divisor is Fp2Operations.P\n * \n * A group generator is {1, 2}\n * \n * Defined operations:\n * \n * - check if a point is in the group G1\n * - check if a point is in the field Fp2\n * - for x of Fp calculate -x\n */\nlibrary G1Operations {\n    using Fp2Operations for IFieldOperations.Fp2Point;\n\n    /**\n     * @dev Get G1 group generator\n     */\n    function getG1Generator() internal pure returns (IFieldOperations.Fp2Point memory) {\n        // Current solidity version does not support Constants of non-value type\n        // so we implemented this function\n        return IFieldOperations.Fp2Point({\n            a: 1,\n            b: 2\n        });\n    }\n\n    /**\n     * @dev Check if ({x], {y}) is a G1 element\n     */\n    function isG1Point(uint x, uint y) internal pure returns (bool) {\n        uint p = Fp2Operations.P;\n        return mulmod(y, y, p) == \n            addmod(mulmod(mulmod(x, x, p), x, p), 3, p);\n    }\n\n    /**\n     * @dev Check if {point} is a G1 element\n     */\n    function isG1(IFieldOperations.Fp2Point memory point) internal pure returns (bool) {\n        return isG1Point(point.a, point.b);\n    }\n\n    /**\n     * @dev Check if {point} is a Fp2 element\n     */\n    function checkRange(IFieldOperations.Fp2Point memory point) internal pure returns (bool) {\n        return point.a < Fp2Operations.P && point.b < Fp2Operations.P;\n    }\n\n    /**\n     * @dev For {y} of Fp calculate -y\n     */\n    function negate(uint y) internal pure returns (uint) {\n        return (Fp2Operations.P - y) % Fp2Operations.P;\n    }\n\n}\n\n/**\n * @title G2Operations\n * @dev This library contains operations of a group of elements {x, y}\n * where y^2 = x^3 + TWISTB and x and y are elements of Fp2\n * \n * Element of the group is G2Point\n * \n * Prime divisor is Fp2Operations.P\n * TWISTB is\n * {\n *     19485874751759354771024239261021720505790618469301721065564631296452457478373,\n *     266929791119991161246907387137283842545076965332900288569378510910307636690\n * }\n * A group generator is\n * {\n *     {\n *         10857046999023057135944570762232829481370756359578518086990519993285655852781,\n *         11559732032986387107991004021392285783925812861821192530917403151452391805634\n *     },\n *     {\n *         8495653923123431417604973247489272438418190587263600148770280649306958101930,\n *         4082367875863433681332203403145435568316851327593401208105741076214120093531\n *     }\n * }\n * \n * Defined operations:\n * \n * - check if a point is in the group G2\n * - check if a point is zero element of group G2\n * - comparison for equality\n */\nlibrary G2Operations {\n    using Fp2Operations for IFieldOperations.Fp2Point;\n\n\n    /**\n     * @dev Get value of TWISTB\n     */\n    function getTWISTB() internal pure returns (IFieldOperations.Fp2Point memory) {\n        // Current solidity version does not support Constants of non-value type\n        // so we implemented this function\n        return IFieldOperations.Fp2Point({\n            a: 19485874751759354771024239261021720505790618469301721065564631296452457478373,\n            b: 266929791119991161246907387137283842545076965332900288569378510910307636690\n        });\n    }\n\n    /**\n     * @dev Get G2 group generator\n     */\n    function getG2Generator() internal pure returns (IFieldOperations.G2Point memory) {\n        // Current solidity version does not support Constants of non-value type\n        // so we implemented this function\n        return IFieldOperations.G2Point({\n            x: IFieldOperations.Fp2Point({\n                a: 10857046999023057135944570762232829481370756359578518086990519993285655852781,\n                b: 11559732032986387107991004021392285783925812861821192530917403151452391805634\n            }),\n            y: IFieldOperations.Fp2Point({\n                a: 8495653923123431417604973247489272438418190587263600148770280649306958101930,\n                b: 4082367875863433681332203403145435568316851327593401208105741076214120093531\n            })\n        });\n    }\n\n    /**\n     * @dev Get G2 zero element\n     */\n    function getG2Zero() internal pure returns (IFieldOperations.G2Point memory) {\n        // Current solidity version does not support Constants of non-value type\n        // so we implemented this function\n        return IFieldOperations.G2Point({\n            x: IFieldOperations.Fp2Point({\n                a: 0,\n                b: 0\n            }),\n            y: IFieldOperations.Fp2Point({\n                a: 1,\n                b: 0\n            })\n        });\n    }\n\n    /**\n     * @dev Check if ({x}, {y}) is an element of G2\n     */\n    function isG2Point(\n        IFieldOperations.Fp2Point memory x,\n        IFieldOperations.Fp2Point memory y\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (isG2ZeroPoint(x, y)) {\n            return true;\n        }\n        IFieldOperations.Fp2Point memory squaredY = y.squaredFp2();\n        IFieldOperations.Fp2Point memory res = squaredY.minusFp2(\n                x.squaredFp2().mulFp2(x)\n            ).minusFp2(getTWISTB());\n        return res.a == 0 && res.b == 0;\n    }\n\n    /**\n     * @dev Check if {value} is an element of G2\n     */\n    function isG2(IFieldOperations.G2Point memory value) internal pure returns (bool) {\n        return isG2Point(value.x, value.y);\n    }\n\n    /**\n     * @dev Check if ({x}, {y}) is a zero element of G2\n     */\n    function isG2ZeroPoint(\n        IFieldOperations.Fp2Point memory x,\n        IFieldOperations.Fp2Point memory y\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return x.a == 0 && x.b == 0 && y.a == 1 && y.b == 0;\n    }\n\n    /**\n     * @dev Check if {value} is a zero element of G2\n     */\n    function isG2Zero(IFieldOperations.G2Point memory value) internal pure returns (bool) {\n        return value.x.a == 0 && value.x.b == 0 && value.y.a == 1 && value.y.b == 0;\n    }\n\n    /**\n     * @dev Check if {value1} is equal to {value2}\n     */\n    function isEqual(\n        IFieldOperations.G2Point memory value1,\n        IFieldOperations.G2Point memory value2\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return value1.x.isEqual(value2.x) && value1.y.isEqual(value2.y);\n    }\n}\n"
            },
            "contracts/schain/TokenManagers/TokenManagerERC721WithMetadata.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManagerERC721WithMetadata.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./TokenManagerERC721.sol\";\nimport \"../../Messages.sol\";\n\n\n/**\n * @title TokenManagerERC721WithMetadata\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC721 clones.\n * TokenManagerERC721 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC721WithMetadata is TokenManagerERC721 {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC721_WITH_METADATA\n        ) {\n            receiver = _sendERC721(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n    }\n\n    /**\n     * @dev Allows TokenManager to send ERC721 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC721(bytes32 fromChainHash, bytes calldata data) internal override returns (address) {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        address receiver;\n        address token;\n        uint256 tokenId;\n        string memory tokenURI;\n        ERC721OnChain contractOnSchain;\n        if (messageType == Messages.MessageType.TRANSFER_ERC721_WITH_METADATA) {\n            Messages.TransferErc721MessageWithMetadata memory message =\n                Messages.decodeTransferErc721MessageWithMetadata(data);\n            receiver = message.erc721message.receiver;\n            token = message.erc721message.token;\n            tokenId = message.erc721message.tokenId;\n            tokenURI = message.tokenURI;\n            contractOnSchain = clonesErc721[fromChainHash][token];\n        } else {\n            Messages.TransferErc721WithMetadataAndTokenInfoMessage memory message =\n                Messages.decodeTransferErc721WithMetadataAndTokenInfoMessage(data);\n            receiver = message.baseErc721transferWithMetadata.erc721message.receiver;\n            token = message.baseErc721transferWithMetadata.erc721message.token;\n            tokenId = message.baseErc721transferWithMetadata.erc721message.tokenId;\n            tokenURI = message.baseErc721transferWithMetadata.tokenURI;\n            contractOnSchain = clonesErc721[fromChainHash][token];\n            if (address(contractOnSchain) == address(0)) {\n                require(automaticDeploy, \"Automatic deploy is disabled\");\n                contractOnSchain = new ERC721OnChain(message.tokenInfo.name, message.tokenInfo.symbol);           \n                clonesErc721[fromChainHash][token] = contractOnSchain;\n                addedClones[contractOnSchain] = true;\n                emit ERC721TokenCreated(fromChainHash, token, address(contractOnSchain));\n            }\n        }\n        if (\n            messageType == Messages.MessageType.TRANSFER_ERC721_WITH_METADATA &&\n            fromChainHash != MAINNET_HASH &&\n            _isERC721AddedToSchain(fromChainHash, token)\n        ) {\n            require(token.isContract(), \"Incorrect main chain token\");\n            require(IERC721Upgradeable(token).ownerOf(tokenId) == address(this), \"Incorrect tokenId\");\n            _removeTransferredAmount(fromChainHash, token, tokenId);\n            IERC721Upgradeable(token).transferFrom(address(this), receiver, tokenId);\n        } else {\n            contractOnSchain.mint(receiver, tokenId);\n            contractOnSchain.setTokenURI(tokenId, tokenURI);\n        }\n        emit ERC721TokenReceived(fromChainHash, token, address(contractOnSchain), tokenId);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        override\n    {\n        bool isMainChainToken;\n        ERC721OnChain contractOnSchain = clonesErc721[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC721OnChain(contractOnMainChain);\n            require(!addedClones[contractOnSchain], \"Incorrect main chain token\");\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.getApproved(tokenId) == address(this), \"Not allowed ERC721 Token\");\n        bytes memory data = Messages.encodeTransferErc721MessageWithMetadata(\n            contractOnMainChain,\n            to,\n            tokenId,\n            _getTokenURI(IERC721MetadataUpgradeable(contractOnSchain), tokenId)\n        );\n        if (isMainChainToken) {\n            require(chainHash != MAINNET_HASH, \"Main chain token could not be transfered to Mainnet\");\n            data = _receiveERC721(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                tokenId\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), tokenId);\n            contractOnSchain.transferFrom(msg.sender, address(this), tokenId);\n        } else {\n            contractOnSchain.transferFrom(msg.sender, address(this), tokenId);\n            contractOnSchain.burn(tokenId);\n        }\n        messageProxy.postOutgoingMessage(chainHash, messageReceiver, data);\n    }\n\n    /**\n     * @dev Allows DepositBoxERC721 to receive ERC721 tokens.\n     * \n     * Emits an {ERC721TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC721.\n     */\n    function _receiveERC721(\n        bytes32 chainHash,\n        address erc721OnMainChain,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        override\n        returns (bytes memory data)\n    {\n        bool isERC721AddedToSchain = _isERC721AddedToSchain(chainHash, erc721OnMainChain);\n        if (!isERC721AddedToSchain) {\n            _addERC721ForSchain(chainHash, erc721OnMainChain);\n            data = Messages.encodeTransferErc721WithMetadataAndTokenInfoMessage(\n                erc721OnMainChain,\n                to,\n                tokenId,\n                _getTokenURI(IERC721MetadataUpgradeable(erc721OnMainChain), tokenId),\n                _getTokenInfo(IERC721MetadataUpgradeable(erc721OnMainChain))\n            );\n        } else {\n            data = Messages.encodeTransferErc721MessageWithMetadata(\n                erc721OnMainChain,\n                to,\n                tokenId,\n                _getTokenURI(IERC721MetadataUpgradeable(erc721OnMainChain), tokenId)\n            );\n        }\n        emit ERC721TokenReady(chainHash, erc721OnMainChain, tokenId);\n    }\n\n    /**\n     * @dev Returns tokenURI of ERC721 token.\n     */\n    function _getTokenURI(IERC721MetadataUpgradeable erc721, uint256 tokenId) private view returns (string memory) {\n        return erc721.tokenURI(tokenId);\n    }\n\n}"
            },
            "contracts/test/MessagesTester.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessagesTester.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"../Messages.sol\";\n\n\ninterface IMessagesTester {\n    function encodeTransferEthMessage(address receiver, uint256 amount) external pure returns (bytes memory);\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external pure returns (bytes memory);\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) external pure returns (bytes memory);\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Messages.Erc20TokenInfo memory tokenInfo\n    ) external pure returns (bytes memory);\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) external pure returns (bytes memory);\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Messages.Erc721TokenInfo memory tokenInfo\n    ) external pure returns (bytes memory);\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) external pure returns (bytes memory);\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Messages.Erc721TokenInfo memory tokenInfo\n    ) external pure returns (bytes memory);\n    function encodeActivateUserMessage(address receiver) external pure returns (bytes memory);\n    function encodeLockUserMessage(address receiver) external pure returns (bytes memory);\n    function encodeInterchainConnectionMessage(bool isAllowed) external pure returns (bytes memory);\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) external pure returns (bytes memory);\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Messages.Erc1155TokenInfo memory tokenInfo\n    ) external pure returns (bytes memory);\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external pure returns (bytes memory);\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Messages.Erc1155TokenInfo memory tokenInfo\n    ) external pure returns (bytes memory);\n}\n\n\ncontract MessagesTester is IMessagesTester {\n\n    function encodeTransferEthMessage(address receiver, uint256 amount) external pure override returns (bytes memory) {\n        return Messages.encodeTransferEthMessage(receiver, amount);\n    }\n\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc20Message(token, receiver, amount);\n    }\n\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc20AndTotalSupplyMessage(token, receiver, amount, totalSupply);\n    }\n\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Messages.Erc20TokenInfo memory tokenInfo\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc20AndTokenInfoMessage(token, receiver, amount, totalSupply, tokenInfo);\n    }\n\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc721Message(token, receiver, tokenId);\n    }\n\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Messages.Erc721TokenInfo memory tokenInfo\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc721AndTokenInfoMessage(token, receiver, tokenId, tokenInfo);\n    }\n\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc721MessageWithMetadata(token, receiver, tokenId, tokenURI);\n    }\n\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Messages.Erc721TokenInfo memory tokenInfo\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc721WithMetadataAndTokenInfoMessage(\n            token,\n            receiver,\n            tokenId,\n            tokenURI,\n            tokenInfo\n        );\n    }\n\n    function encodeActivateUserMessage(address receiver) external pure override returns (bytes memory) {\n        return Messages.encodeActivateUserMessage(receiver);\n    }\n\n    function encodeLockUserMessage(address receiver) external pure override returns (bytes memory) {\n        return Messages.encodeLockUserMessage(receiver);\n    }\n\n    function encodeInterchainConnectionMessage(bool isAllowed) external pure override returns (bytes memory) {\n        return Messages.encodeInterchainConnectionMessage(isAllowed);\n    }\n\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc1155Message(token, receiver, id, amount);\n    }\n\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Messages.Erc1155TokenInfo memory tokenInfo\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc1155AndTokenInfoMessage(token, receiver, id, amount, tokenInfo);\n    }\n\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc1155BatchMessage(token, receiver, ids, amounts);\n    }\n\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Messages.Erc1155TokenInfo memory tokenInfo\n    ) external pure override returns (bytes memory) {\n        return Messages.encodeTransferErc1155BatchAndTokenInfoMessage(token, receiver, ids, amounts, tokenInfo);\n    }\n}"
            },
            "contracts/schain/TokenManagers/TokenManagerEth.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerEth.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerEth\n * @dev Runs on SKALE Chains and\n * accepts messages from mainnet.\n * TokenManagerEth mints EthErc20 tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerEth is TokenManager, ITokenManagerEth {\n\n    IEthErc20 public ethErc20;\n\n    /// Create a new token manager    \n\n    /**\n     * @dev Register EthErc20 token.\n     */\n    function setEthErc20Address(IEthErc20 newEthErc20Address) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\");\n        require(ethErc20 != newEthErc20Address, \"Must be new address\");\n        ethErc20 = newEthErc20Address;\n    }\n\n    /**\n     * @dev Move ETH from schain to mainnet.\n     * \n     * EthErc20 tokens are burned on schain and ETH are unlocked on mainnet for {to} address.\n     */\n    function exitToMain(uint256 amount) external override {\n        communityLocker.checkAllowedToSendMessage(MAINNET_HASH, msg.sender);\n        _exit(MAINNET_HASH, depositBox, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n    {\n        Messages.TransferEthMessage memory decodedMessage = Messages.decodeTransferEthMessage(data);\n        address receiver = decodedMessage.receiver;\n        require(receiver != address(0), \"Incorrect receiver\");\n        ethErc20.mint(receiver, decodedMessage.amount);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox,\n        IEthErc20 ethErc20Address\n    )\n        external\n        override\n        initializer\n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n        ethErc20 = ethErc20Address;\n    }\n\n    // private\n\n    /**\n     * @dev Checks whether sender contract is DepositBox.\n     */\n    function _checkSender(bytes32 fromChainHash, address sender) internal view override returns (bool) {\n        return fromChainHash == MAINNET_HASH && sender == depositBox;\n    }\n\n    /**\n     * @dev Burn EthErc20 tokens on schain and send message to unlock ETH on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        if (amount > 0) {\n            ethErc20.forceBurn(msg.sender, amount);\n        }\n        bytes memory data = Messages.encodeTransferEthMessage(to, amount);\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerEth.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerEth - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../tokens/IEthErc20.sol\";\nimport \"../ICommunityLocker.sol\";\nimport \"../IMessageProxyForSchain.sol\";\nimport \"../ITokenManager.sol\";\nimport \"../ITokenManagerLinker.sol\";\n\n\ninterface ITokenManagerEth is ITokenManager {\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox,\n        IEthErc20 ethErc20Address\n    ) external;\n    function setEthErc20Address(IEthErc20 newEthErc20Address) external;\n    function exitToMain(uint256 amount) external;\n}"
            },
            "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
            },
            "contracts/schain/TokenManagers/TokenManagerERC20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC20OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC20\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC20 clones.\n * TokenManagerERC20 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC20 is TokenManager, ITokenManagerERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC20 on Mainnet => ERC20 on Schain\n    mapping(address => ERC20OnChain) public deprecatedClonesErc20;\n    \n    // address of clone on schain => totalSupplyOnMainnet\n    mapping(IERC20Upgradeable => uint) public totalSupplyOnMainnet;\n\n    // address clone on schain => added or not\n    mapping(ERC20OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC20OnChain)) public clonesErc20;\n\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when schain owner register new ERC20 clone.\n     */\n    event ERC20TokenAdded(bytes32 indexed chainHash, address indexed erc20OnMainChain, address indexed erc20OnSchain);\n\n    /**\n     * @dev Emitted when TokenManagerERC20 automatically deploys new ERC20 clone.\n     */\n    event ERC20TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC20TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(MAINNET_HASH, msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        communityLocker.checkAllowedToSendMessage(targetSchainHash, msg.sender);\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC20 ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY\n        ) {\n            receiver = _sendERC20(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC20 token clone in the TokenManager.\n     */\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainChain,\n        address erc20OnSchain\n     )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc20OnSchain.isContract(), \"Given address is not a contract\");\n        require(ERC20OnChain(erc20OnSchain).totalSupply() == 0, \"TotalSupply is not zero\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc20[targetChainHash][erc20OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC20OnChain(erc20OnSchain)], \"Clone was already added\");\n        clonesErc20[targetChainHash][erc20OnMainChain] = ERC20OnChain(erc20OnSchain);\n        addedClones[ERC20OnChain(erc20OnSchain)] = true;\n        emit ERC20TokenAdded(targetChainHash, erc20OnMainChain, erc20OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override        \n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC20 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC20(bytes32 fromChainHash, bytes calldata data) private returns (address) {        \n        Messages.MessageType messageType = Messages.getMessageType(data);\n        (address receiver, address token, uint256 amount) = _decodeErc20Message(data);\n        ERC20OnChain contractOnSchain;\n        if (messageType != Messages.MessageType.TRANSFER_ERC20) {\n            uint256 totalSupply;\n            if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n                Messages.TransferErc20AndTotalSupplyMessage memory message =\n                    Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n            } else {\n                Messages.TransferErc20AndTokenInfoMessage memory message =\n                    Messages.decodeTransferErc20AndTokenInfoMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n\n                if (address(contractOnSchain) == address(0)) {\n                    require(automaticDeploy, \"Automatic deploy is disabled\");\n                    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n                    clonesErc20[fromChainHash][token] = contractOnSchain;\n                    addedClones[contractOnSchain] = true;\n                    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n                }\n            }\n            if (totalSupply != totalSupplyOnMainnet[contractOnSchain]) {\n                totalSupplyOnMainnet[contractOnSchain] = totalSupply;\n            }\n            bool noOverflow;\n            uint updatedTotalSupply;\n            (noOverflow, updatedTotalSupply) = SafeMathUpgradeable.tryAdd(contractOnSchain.totalSupply(), amount);\n            require(\n                noOverflow && updatedTotalSupply <= totalSupplyOnMainnet[contractOnSchain],\n                \"Total supply exceeded\"\n            );\n            contractOnSchain.mint(receiver, amount);\n        } else {\n            require(token.isContract() && _schainToERC20[fromChainHash].contains(token), \"Incorrect main chain token\");\n            require(ERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Not enough money\");\n            _removeTransferredAmount(fromChainHash, token, amount);\n            require(\n                ERC20Upgradeable(token).transfer(receiver, amount),\n                \"Transfer was failed\"\n            );\n        }\n        emit ERC20TokenReceived(fromChainHash, token, address(contractOnSchain), amount);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20OnChain contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20OnChain(contractOnMainChain);\n            require(!addedClones[contractOnSchain], \"Incorrect main chain token\");\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            require(chainHash != MAINNET_HASH, \"Main chain token could not be transfered to Mainnet\");\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(bytes32 chainHash, address erc20OnMainChain) private {\n        require(erc20OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[chainHash].contains(erc20OnMainChain), \"ERC20 Token was already added\");\n        _schainToERC20[chainHash].add(erc20OnMainChain);\n        emit ERC20TokenAdded(chainHash, erc20OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n\n\n    /**\n     * @dev Decodes ERC20 transfer message depending on type of message.\n     */\n    function _decodeErc20Message(bytes calldata data)\n        private\n        pure\n        returns (address, address, uint256)\n    {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        if (messageType == Messages.MessageType.TRANSFER_ERC20) {\n            Messages.TransferErc20Message memory message =\n                Messages.decodeTransferErc20Message(data);\n            return (\n                message.receiver,\n                message.token,\n                message.amount\n            );\n        } else if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n            Messages.TransferErc20AndTotalSupplyMessage memory messageTotalSupply =\n                Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n            return (\n                messageTotalSupply.baseErc20transfer.receiver,\n                messageTotalSupply.baseErc20transfer.token,\n                messageTotalSupply.baseErc20transfer.amount\n            );\n        } else {\n            Messages.TransferErc20AndTokenInfoMessage memory messageTokenInfo =\n                Messages.decodeTransferErc20AndTokenInfoMessage(data);\n            return (\n                messageTokenInfo.baseErc20transfer.receiver,\n                messageTokenInfo.baseErc20transfer.token,\n                messageTokenInfo.baseErc20transfer.amount\n            );\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerERC20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./ITokenContractManager.sol\";\n\ninterface ITokenManagerERC20 is ITokenContractManager {\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    ) external;\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    ) external;\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainnet,\n        address erc20OnSchain\n    ) external;\n}"
            },
            "contracts/schain/tokens/ERC20OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC20OnChain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IERC20OnChain.sol\";\n\n\n/**\n * @title ERC20OnChain\n * @dev ERC20 token that is used as an automatically deployed clone of ERC20 on mainnet.\n */\ncontract ERC20OnChain is AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, IERC20OnChain {\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory contractName,\n        string memory contractSymbol\n    ) initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);\n        ERC20BurnableUpgradeable.__ERC20Burnable_init();\n        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Mint tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(address account, uint256 value) external override {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mint(account, value);\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/tokens/IERC20OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IERC20OnChain - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IERC20OnChain {\n    function mint(address account, uint256 value) external;\n}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
            },
            "contracts/test/EtherbaseMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   EtherbaseMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/etherbase-interfaces/IEtherbaseUpgradeable.sol\";\n\n\ncontract EtherbaseMock is IEtherbaseUpgradeable, AccessControlEnumerableUpgradeable {\n    bytes32 public constant override ETHER_MANAGER_ROLE = keccak256(\"ETHER_MANAGER_ROLE\");\n\n    event EtherReceived(\n        address sender,\n        uint amount\n    );\n\n    event EtherSent(\n        address receiver,\n        uint amount\n    );\n\n    modifier onlyEtherManager() {\n        require(hasRole(ETHER_MANAGER_ROLE, msg.sender), \"ETHER_MANAGER_ROLE is required\");\n        _;\n    }\n\n    receive() external payable override {\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    function retrieve(address payable receiver) external override onlyEtherManager {\n        partiallyRetrieve(receiver, address(this).balance);\n    }\n\n    function initialize(address schainOwner) external initializer override\n    {\n        AccessControlUpgradeable.__AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, schainOwner);\n        _setupRole(ETHER_MANAGER_ROLE, schainOwner);\n    }\n\n    function partiallyRetrieve(address payable receiver, uint amount) public override onlyEtherManager {\n        require(receiver != address(0), \"Receiver address is not set\");\n        require(amount <= address(this).balance, \"Insufficient funds\");\n\n        emit EtherSent(receiver, amount);\n\n        receiver.transfer(amount);\n    }\n}"
            },
            "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
            },
            "contracts/test/erc20/RevertableERC20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
            },
            "contracts/test/TestContractManager.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestContractManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\ninterface IContractManagerTester {\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function getContract(string memory contractName) external view returns (address);\n}\n\ncontract ContractManager is IContractManagerTester {\n    using AddressUpgradeable for address;\n\n    // mapping of actual smart contracts addresses\n    mapping (bytes32 => address) public contracts;\n\n    address public owner;\n\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * Adds actual contract to mapping of actual contract addresses\n     * @param contractsName - contracts name in skale manager system\n     * @param newContractsAddress - contracts address in skale manager system\n     */\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external override {\n        // check newContractsAddress is not equal zero\n        require(newContractsAddress != address(0), \"New address is equal zero\");\n        // create hash of contractsName\n        bytes32 contractId = keccak256(abi.encodePacked(contractsName));\n        // check newContractsAddress is not equal the previous contract's address\n        require(contracts[contractId] != newContractsAddress, \"Contract is already added\");\n        // check newContractsAddress contains code\n        require(newContractsAddress.isContract(), \"Given contracts address is not contain code\");\n        // add newContractsAddress to mapping of actual contract addresses\n        contracts[contractId] = newContractsAddress;\n        emit ContractUpgraded(contractsName, newContractsAddress);\n    }\n\n    /**\n     * @dev Returns the contract address for a given contractName.\n     */\n    function getContract(string memory contractName) external view override returns (address) {\n        return contracts[keccak256(abi.encodePacked(contractName))];\n    }\n}\n"
            },
            "contracts/test/TestSchainsInternal.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestSchainsInternal.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"./TestContractManager.sol\";\nimport \"./TestNodes.sol\";\n\n\ninterface ISchainsInternalTester {\n    function addContractManager(address newContractManager) external;\n    function initializeSchain(\n        string calldata name,\n        address from,\n        uint lifetime,\n        uint deposit) external;\n    function addNodesToSchainsGroups(bytes32 schainHash, uint[] memory nodes) external;\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n}\n\n\ncontract SchainsInternal is ISchainsInternalTester {\n\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n    }\n\n    ContractManager public contractManager;\n\n    mapping (bytes32 => Schain) public schains;\n\n    mapping (bytes32 => bool) public isSchainActive;\n\n    mapping (bytes32 => uint[]) public schainsGroups;\n\n    bytes32[] public schainsAtSystem;\n\n    mapping (bytes32 => mapping (address => bool)) private _nodeAddressInSchain;\n\n    function addContractManager(address newContractManager) external override {\n        contractManager = ContractManager(newContractManager);\n    }\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        uint lifetime,\n        uint deposit) external override\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(name));\n        schains[schainHash].name = name;\n        schains[schainHash].owner = from;\n        schains[schainHash].startDate = block.timestamp;\n        schains[schainHash].startBlock = block.number;\n        schains[schainHash].lifetime = lifetime;\n        schains[schainHash].deposit = deposit;\n        schains[schainHash].index = 1337;\n        isSchainActive[schainHash] = true;\n        schainsAtSystem.push(schainHash);\n    }\n\n    function addNodesToSchainsGroups(bytes32 schainHash, uint[] memory nodes) external override {\n        Nodes nodesContract = Nodes(contractManager.getContract(\"Nodes\"));\n        schainsGroups[schainHash] = nodes;\n        for (uint i = 0; i < nodes.length; i++) {\n            address nodeAddress = nodesContract.getNodeAddress(nodes[i]);\n            _nodeAddressInSchain[schainHash][nodeAddress] = true;\n        }\n    }\n\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view override returns (bool) {\n        return  _nodeAddressInSchain[schainHash][sender];\n    }\n\n    function isOwnerAddress(address from, bytes32 schainHash) external view override returns (bool) {\n        return schains[schainHash].owner == from;\n    }\n\n    function getSchains() external view override returns (bytes32[] memory) {\n        return schainsAtSystem;\n    }\n\n    function getSchainName(bytes32 schainHash)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        return schains[schainHash].name;\n    }\n\n    function getNodesInGroup(bytes32 schainHash)\n        external\n        view\n        override\n        returns (uint[] memory)\n    {\n        return schainsGroups[schainHash];\n    }\n\n    function isSchainExist(bytes32) external pure override returns (bool) {\n        return true;\n    }\n}\n"
            },
            "contracts/test/TestNodes.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestNodes.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\n\ninterface INodesTester {\n    function createNode(address, Nodes.NodeCreationParams calldata params) external;\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n}\n\n\ncontract Nodes is INodesTester {\n\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    Node[] public nodes;\n\n    mapping (address => CreatedNodes) public nodeIndexes;\n\n    modifier checkNodeExists(uint nodeIndex) {\n        _checkNodeIndex(nodeIndex);\n        _;\n    }\n\n    function createNode(address from, NodeCreationParams calldata params)\n        external override\n    {\n        nodes.push(Node({\n            name: params.name,\n            ip: params.ip,\n            publicIP: params.publicIp,\n            port: params.port,\n            publicKey: params.publicKey,\n            startBlock: block.number,\n            lastRewardDate: block.timestamp,\n            finishTime: 0,\n            status: NodeStatus.Active,\n            validatorId: 1337\n        }));\n        nodeIndexes[from].isNodeExist[nodes.length - 1] = true;\n        nodeIndexes[from].numberOfNodes++;\n    }\n\n    function getNodeAddress(uint nodeIndex)\n        external\n        view\n        override\n        checkNodeExists(nodeIndex)\n        returns (address)\n    {\n        return _publicKeyToAddress(nodes[nodeIndex].publicKey);\n    }\n\n    function isNodeExist(address from, uint nodeIndex)\n        public\n        view\n        override\n        checkNodeExists(nodeIndex)\n        returns (bool)\n    {\n        return nodeIndexes[from].isNodeExist[nodeIndex];\n    }\n\n    function _checkNodeIndex(uint nodeIndex) private view {\n        require(nodeIndex < nodes.length, \"Node with such index does not exist\");\n    }\n\n    function _publicKeyToAddress(bytes32[2] memory pubKey) private pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(pubKey[0], pubKey[1]));\n        bytes20 addr;\n        for (uint8 i = 12; i < 32; i++) {\n            addr |= bytes20(hash[i] & 0xFF) >> ((i - 12) * 8);\n        }\n        return address(addr);\n    }\n}\n"
            },
            "contracts/test/TestWallets.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestWallets.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"./TestSchainsInternal.sol\";\n\ninterface IWalletsTester {\n    function addContractManager(address newContractManager) external;\n     function refundGasBySchain(\n        bytes32 schainHash,\n        address payable spender,\n        uint spentGas,\n        bool\n    ) external;\n    function rechargeSchainWallet(bytes32 schainHash) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n}\n\n\ncontract Wallets is IWalletsTester {\n\n    ContractManager public contractManager;\n\n    mapping (bytes32 => uint) private _schainWallets;\n\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    function addContractManager(address newContractManager) external override {\n        contractManager = ContractManager(newContractManager);\n    }\n\n    function refundGasBySchain(\n        bytes32 schainHash,\n        address payable spender,\n        uint spentGas,\n        bool\n    )\n        external\n        override\n    {\n        uint amount = tx.gasprice * spentGas;\n        require(schainHash != bytes32(0), \"SchainHash cannot be null\");\n        require(amount <= _schainWallets[schainHash], \"Schain wallet has not enough funds\");\n        _schainWallets[schainHash] -= amount;\n        emit NodeRefundedBySchain(spender, schainHash, amount);\n        spender.transfer(amount);\n    }\n\n    function rechargeSchainWallet(bytes32 schainHash) external payable override {\n        SchainsInternal schainsInternal = SchainsInternal(contractManager.getContract(\"SchainsInternal\"));\n        require(schainsInternal.isSchainActive(schainHash), \"Schain should be active for recharging\");\n        _schainWallets[schainHash] += msg.value;\n        emit SchainWalletRecharged(msg.sender, msg.value, schainHash);\n    }\n\n    function getSchainBalance(bytes32 schainHash) external view override returns (uint) {\n        return _schainWallets[schainHash];\n    }\n}\n"
            },
            "contracts/test/TestSchains.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestSchains.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"./TestContractManager.sol\";\nimport \"./KeyStorageMock.sol\";\nimport \"./SkaleVerifierMock.sol\";\n\n\ninterface ISchainsTester {\n    function addContractManager(address newContractManager) external;\n        function verifySchainSignature(\n        uint signatureA,\n        uint signatureB,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n}\n\n\ncontract Schains is ISchainsTester {\n\n    ContractManager public contractManager;\n\n    function addContractManager(address newContractManager) external override {\n        contractManager = ContractManager(newContractManager);\n    }\n\n    function verifySchainSignature(\n        uint signatureA,\n        uint signatureB,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        string calldata schainName\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        SkaleVerifierMock skaleVerifier = SkaleVerifierMock(contractManager.getContract(\"SkaleVerifier\"));\n        IFieldOperations.G2Point memory publicKey = KeyStorageMock(\n            contractManager.getContract(\"KeyStorage\")\n        ).getBlsCommonPublicKeyForSchain(\n            keccak256(abi.encodePacked(schainName))\n        );\n        return skaleVerifier.verify(\n            IFieldOperations.Fp2Point({\n                a: signatureA,\n                b: signatureB\n            }),\n            hash, counter,\n            hashA, hashB,\n            publicKey\n        );\n    }\n}\n"
            },
            "contracts/test/KeyStorageMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   KeyStorageMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"../schain/KeyStorage.sol\";\n\n\ninterface IKeyStorageMock is IKeyStorage {\n    function setBlsCommonPublicKey(IFieldOperations.G2Point calldata key) external;\n    function setBlsCommonPublicKeyForSchain(bytes32 schainHash, IFieldOperations.G2Point calldata key) external;\n    function getBlsCommonPublicKeyForSchain(bytes32 schainHash) external view returns (IFieldOperations.G2Point memory);\n}\n\n\ncontract KeyStorageMock is KeyStorage, IKeyStorageMock {\n    \n    IFieldOperations.G2Point public blsCommonPublicKey;\n    mapping (bytes32 => IFieldOperations.G2Point) public blsCommonPublicKeys;\n    string public hello = \"Hello\";\n\n    function setBlsCommonPublicKey(IFieldOperations.G2Point calldata key) external override {\n        // TODO: remove when update compiler will be updated\n        IFieldOperations.G2Point memory _key = key;\n        blsCommonPublicKey = _key;        \n    }\n\n    function setBlsCommonPublicKeyForSchain(\n        bytes32 schainHash,\n        IFieldOperations.G2Point calldata key\n    )\n        external\n        override\n    {\n        // TODO: remove when update compiler will be updated\n        IFieldOperations.G2Point memory _key = key;\n        blsCommonPublicKeys[schainHash] = _key;\n    }\n\n    function getBlsCommonPublicKey()\n        external\n        view\n        override(IKeyStorage, KeyStorage)\n        returns (IFieldOperations.G2Point memory)\n    {\n        require(\n            !(blsCommonPublicKey.x.a == 0 &&\n              blsCommonPublicKey.x.b == 0 &&\n              blsCommonPublicKey.y.a == 0 &&\n              blsCommonPublicKey.y.b == 0),\n            \"BLS common public key is not set in the mock\"\n        );\n        return blsCommonPublicKey;\n    }\n\n    function getBlsCommonPublicKeyForSchain(\n        bytes32 schainHash\n    )\n        external\n        view\n        override\n        returns (IFieldOperations.G2Point memory)\n    {\n        IFieldOperations.G2Point memory key = blsCommonPublicKeys[schainHash];\n        require(\n            !(key.x.a == 0 &&\n              key.x.b == 0 &&\n              key.y.a == 0 &&\n              key.y.b == 0),\n            \"BLS common public key is not set in the mock\"\n        );\n        return key;\n    }\n}\n\n"
            },
            "contracts/test/SkaleVerifierMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestSkaleVerifier.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"../schain/bls/FieldOperations.sol\";\n\nimport \"./PrecompiledMock.sol\";\n\n\ninterface ISkaleVerifierMock {\n    function verify(\n        IFieldOperations.Fp2Point calldata signature,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        IFieldOperations.G2Point calldata publicKey\n    )\n        external\n        view\n        returns (bool);\n}\n\n\ncontract SkaleVerifierMock is ISkaleVerifierMock {\n\n    /**\n    * @dev Verifies a BLS signature.\n    * \n    * Requirements:\n    * \n    * - Signature is in G1.\n    * - Hash is in G1.\n    * - G2.one in G2.\n    * - Public Key in G2.\n    */\n    function verify(\n        IFieldOperations.Fp2Point calldata signature,\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB,\n        IFieldOperations.G2Point calldata publicKey\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        require(G1Operations.checkRange(signature), \"Signature is not valid\");\n        if (!_checkHashToGroupWithHelper(\n            hash,\n            counter,\n            hashA,\n            hashB\n            )\n        )\n        {\n            return false;\n        }\n\n        uint newSignB = G1Operations.negate(signature.b);\n        require(G1Operations.isG1Point(signature.a, newSignB) || true, \"Sign not in G1\");\n        require(G1Operations.isG1Point(hashA, hashB) || true, \"Hash not in G1\");\n\n        IFieldOperations.G2Point memory g2 = G2Operations.getG2Generator();\n        require(\n            G2Operations.isG2(publicKey),\n            \"Public Key not in G2\"\n        );\n\n        return PrecompiledMock.bn256Pairing(\n            signature.a, newSignB,\n            g2.x.b, g2.x.a, g2.y.b, g2.y.a,\n            hashA, hashB,\n            publicKey.x.b, publicKey.x.a, publicKey.y.b, publicKey.y.a\n        );\n        // return true;\n    }\n\n    function _checkHashToGroupWithHelper(\n        bytes32 hash,\n        uint counter,\n        uint hashA,\n        uint hashB\n    )\n        private\n        pure\n        returns (bool)\n    {\n        if (counter > 100) {\n            return false;\n        }\n        uint xCoordinate = uint(hash) % Fp2Operations.P;\n        xCoordinate = (xCoordinate + counter) % Fp2Operations.P;\n\n        uint ySquared = addmod(\n            mulmod(mulmod(xCoordinate, xCoordinate, Fp2Operations.P), xCoordinate, Fp2Operations.P),\n            3,\n            Fp2Operations.P\n        );\n        if (hashB < Fp2Operations.P / 2 || mulmod(hashB, hashB, Fp2Operations.P) != ySquared || xCoordinate != hashA) {\n            return true;\n        }\n\n        return true;\n    }\n}\n"
            },
            "contracts/schain/KeyStorage.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForSchain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/IKeyStorage.sol\";\n\nimport \"./bls/FieldOperations.sol\";\n\n\n/**\n * @title KeyStorage\n * @dev Holds common BLS public key.\n */\ncontract KeyStorage is IKeyStorage, AccessControlEnumerableUpgradeable {\n\n    uint256 public constant FREE_MEM_PTR = 0x40;\n\n    /**\n     * @dev Address of custom precompiled contract on SKALE chain\n     * to get uin256 value from the config.\n     */\n    uint256 public constant FN_NUM_GET_CONFIG_VARIABLE_UINT256 = 0x13;\n    /**\n     * @dev Address of custom precompiled contract on SKALE chain\n     * to get current BLS public key.\n     */\n    uint256 public constant FN_NUM_GET_CURRENT_BLS_PUBLIC_KEY = 0x19;\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize()\n        external\n        override\n        initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Get BLS common public key.\n     */\n    function getBlsCommonPublicKey() external view override virtual returns (IFieldOperations.G2Point memory) {\n        return _getCurrentBLSPublicKey();\n    }\n\n    // private\n\n    /**\n     * @dev Get uint256 value from the skaled config.\n     */\n    function _getConfigVariableUint256(\n        string memory strConfigVariableName\n    )\n        private\n        view\n        returns ( uint256 rv )\n    {\n        uint256 fmp = FREE_MEM_PTR;\n        uint256 blocks = (bytes(strConfigVariableName).length + 31) / 32 + 1;\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(fmp)\n            for { let i := 0 } lt( i, blocks ) { i := add(1, i) } {\n                let where := add(ptr, mul(32, i))\n                let what := mload(add(strConfigVariableName, mul(32, i)))\n                mstore(where, what)\n            }\n            success := staticcall(not(0), FN_NUM_GET_CONFIG_VARIABLE_UINT256, ptr, mul( blocks, 32 ), ptr, 32)\n            rv := mload(ptr)\n        }\n        require(success, \"Get config uint256 failed\");\n    }\n\n    /**\n     * @dev Get current BLS public key the skaled.\n     */\n    function _getCurrentBLSPublicKey()\n        private\n        view\n        returns ( IFieldOperations.G2Point memory pk )\n    {\n        uint256 fmp = FREE_MEM_PTR;\n        bool success;\n        uint xa;\n        uint xb;\n        uint ya;\n        uint yb;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(fmp)\n            success := staticcall(not(0), FN_NUM_GET_CURRENT_BLS_PUBLIC_KEY, ptr, 0, ptr, 128)\n            xa := mload(ptr)\n            xb := mload(add(ptr, 32))\n            ya := mload(add(ptr, 64))\n            yb := mload(add(ptr, 96))\n        }\n        pk.x.a = xa;\n        pk.x.b = xb;\n        pk.y.a = ya;\n        pk.y.b = yb;\n        require(success, \"Get current BLS public key failed\");\n    }\n}\n"
            },
            "contracts/test/PrecompiledMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TestPrecompiled.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\nlibrary PrecompiledMock {\n\n    function bigModExp(uint base, uint power, uint modulus) internal view returns (uint) {\n        uint[6] memory inputToBigModExp;\n        inputToBigModExp[0] = 32;\n        inputToBigModExp[1] = 32;\n        inputToBigModExp[2] = 32;\n        inputToBigModExp[3] = base;\n        inputToBigModExp[4] = power;\n        inputToBigModExp[5] = modulus;\n        uint[1] memory out;\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success := staticcall(not(0), 5, inputToBigModExp, mul(6, 0x20), out, 0x20)\n        }\n        require(success, \"BigModExp failed\");\n        return out[0];\n    }\n\n    function bn256ScalarMul(uint x, uint y, uint k) internal view returns (uint , uint ) {\n        uint[3] memory inputToMul;\n        uint[2] memory output;\n        inputToMul[0] = x;\n        inputToMul[1] = y;\n        inputToMul[2] = k;\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success := staticcall(not(0), 7, inputToMul, 0x60, output, 0x40)\n        }\n        require(success, \"Multiplication failed\");\n        return (output[0], output[1]);\n    }\n\n    function bn256Pairing(\n        uint x1,\n        uint y1,\n        uint a1,\n        uint b1,\n        uint c1,\n        uint d1,\n        uint x2,\n        uint y2,\n        uint a2,\n        uint b2,\n        uint c2,\n        uint d2)\n        internal view returns (bool)\n    {\n        bool success;\n        uint[12] memory inputToPairing;\n        inputToPairing[0] = x1;\n        inputToPairing[1] = y1;\n        inputToPairing[2] = a1;\n        inputToPairing[3] = b1;\n        inputToPairing[4] = c1;\n        inputToPairing[5] = d1;\n        inputToPairing[6] = x2;\n        inputToPairing[7] = y2;\n        inputToPairing[8] = a2;\n        inputToPairing[9] = b2;\n        inputToPairing[10] = c2;\n        inputToPairing[11] = d2;\n        uint[1] memory out;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success := staticcall(not(0), 8, inputToPairing, mul(12, 0x20), out, 0x20)\n        }\n        // require(success, \"Pairing check failed\");\n        return true;\n    }\n}"
            },
            "contracts/test/TestCallReceiverContract.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ReceiverMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\ncontract TestCallReceiverContract is IMessageReceiver {\n    event Error(uint error);\n\n    function postMessage(\n        bytes32,\n        address,\n        bytes calldata data\n    )\n        external\n        override\n    {\n        uint revertCode = abi.decode(data, (uint));\n        uint one = 1;\n        uint zero = 0;\n        if (revertCode == 1) {\n            revert(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n        } else if (revertCode == 2) {\n            emit Error(one / zero);\n        }\n    }\n}"
            },
            "contracts/test/ReceiverMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ReceiverMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\ncontract ReceiverMock is IMessageReceiver {\n    function postMessage(\n        bytes32,\n        address,\n        bytes calldata\n    )\n        external\n        pure\n        override\n    {\n        return;\n    }\n}\n"
            },
            "contracts/test/ReceiverGasLimitSchainMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ReceiverMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\ncontract ReceiverGasLimitSchainMock is IMessageReceiver {\n    uint public a = 0;\n    function postMessage(\n        bytes32,\n        address,\n        bytes calldata\n    )\n        external\n        override\n    {\n        while(true) {\n            a++;\n        }\n    }\n}"
            },
            "contracts/test/ReceiverGasLimitMainnetMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ReceiverMock.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\ncontract ReceiverGasLimitMainnetMock is IMessageReceiver {\n    uint public a = 0;\n    function postMessage(\n        bytes32,\n        address,\n        bytes calldata\n    )\n        external\n        override\n    {\n        while(true) {\n            a++;\n        }\n    }\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/IDepositBox.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IDepositBox.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"@skalenetwork/skale-manager-interfaces/IContractManager.sol\";\n\nimport \"../IGasReimbursable.sol\";\nimport \"../IMessageReceiver.sol\";\nimport \"./ILinker.sol\";\nimport \"./IMessageProxyForMainnet.sol\";\nimport \"./ITwin.sol\";\n\n\ninterface IDepositBox is ITwin, IMessageReceiver, IGasReimbursable {\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker newLinker,\n        IMessageProxyForMainnet messageProxyValue\n    ) external;\n    function enableWhitelist(string memory schainName) external;\n    function disableWhitelist(string memory schainName) external;\n    function isWhitelisted(string memory schainName) external view returns (bool);\n}"
            },
            "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/ILinker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ILinker.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./ITwin.sol\";\n\n\ninterface ILinker is ITwin {\n    function registerMainnetContract(address newMainnetContract) external;\n    function removeMainnetContract(address mainnetContract) external;\n    function connectSchain(string calldata schainName, address[] calldata schainContracts) external;\n    function kill(string calldata schainName) external;\n    function disconnectSchain(string calldata schainName) external;\n    function isNotKilled(bytes32 schainHash) external view returns (bool);\n    function hasMainnetContract(address mainnetContract) external view returns (bool);\n    function hasSchain(string calldata schainName) external view returns (bool connected);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/IMessageProxyForMainnet.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IMessageProxyForMainnet.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IMessageProxy.sol\";\nimport \"./ICommunityPool.sol\";\n\ninterface IMessageProxyForMainnet is IMessageProxy {\n    function setCommunityPool(ICommunityPool newCommunityPoolAddress) external;\n    function setNewHeaderMessageGasCost(uint256 newHeaderMessageGasCost) external;\n    function setNewMessageGasCost(uint256 newMessageGasCost) external;\n    function pause(string calldata schainName) external;\n    function resume(string calldata schainName) external;\n    function addReimbursedContract(string memory schainName, address reimbursedContract) external;\n    function removeReimbursedContract(string memory schainName, address reimbursedContract) external;\n    function messageInProgress() external view returns (bool);\n    function isPaused(bytes32 schainHash) external view returns (bool);\n    function isReimbursedContract(bytes32 schainHash, address contractAddress) external view returns (bool);\n    function getReimbursedContractsLength(bytes32 schainHash) external view returns (uint256);\n    function getReimbursedContractsRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        returns (address[] memory contractsInRange);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/ITwin.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITwin.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./ISkaleManagerClient.sol\";\n\ninterface ITwin is ISkaleManagerClient {\n    function addSchainContract(string calldata schainName, address contractReceiver) external;\n    function removeSchainContract(string calldata schainName) external;\n    function hasSchainContract(string calldata schainName) external view returns (bool);\n    function getSchainContract(bytes32 schainHash) external view returns (address);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/ISkaleManagerClient.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ISkaleManagerClient.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"@skalenetwork/skale-manager-interfaces/IContractManager.sol\";\n\n\ninterface ISkaleManagerClient {\n    function initialize(IContractManager newContractManagerOfSkaleManager) external;\n    function isSchainOwner(address sender, bytes32 schainHash) external view returns (bool);\n    function isAgentAuthorized(bytes32 schainHash, address sender) external view returns (bool);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ICommunityPool.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"@skalenetwork/skale-manager-interfaces/IContractManager.sol\";\n\n\nimport \"./ILinker.sol\";\nimport \"./IMessageProxyForMainnet.sol\";\nimport \"./ITwin.sol\";\n\n\ninterface ICommunityPool is ITwin {\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linker,\n        IMessageProxyForMainnet messageProxyValue\n    ) external;\n    function refundGasByUser(bytes32 schainHash, address payable node, address user, uint gas) external returns (uint);\n    function rechargeUserWallet(string calldata schainName, address user) external payable;\n    function withdrawFunds(string calldata schainName, uint amount) external;\n    function setMinTransactionGas(uint newMinTransactionGas) external;\n    function setMultiplier(uint newMultiplierNumerator, uint newMultiplierDivider) external;\n    function refundGasBySchainWallet(\n        bytes32 schainHash,\n        address payable node,\n        uint gas\n    ) external returns (bool);\n    function getBalance(address user, string calldata schainName) external view returns (uint);\n    function checkUserBalance(bytes32 schainHash, address receiver) external view returns (bool);\n    function getRecommendedRechargeAmount(bytes32 schainHash, address receiver) external view returns (uint256);\n}"
            },
            "@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxEth.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IDepositBoxEth.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IDepositBox.sol\";\n\n\ninterface IDepositBoxEth is IDepositBox {\n    receive() external payable;\n    function deposit(string memory schainName) external payable;\n    function getMyEth() external;\n    function getFunds(string calldata schainName, address payable receiver, uint amount) external;\n    function enableActiveEthTransfers(string calldata schainName) external;\n    function disableActiveEthTransfers(string calldata schainName) external;\n}"
            },
            "contracts/test/FallbackEthTester.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   FallbackEthTester.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxEth.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\n\ninterface IFallbackEthTester {\n    receive() external payable;\n    function deposit() external payable;\n    function rechargeUserWallet() external payable;\n    function getMyEth() external;\n}\n\n\ncontract FallbackEthTester is IFallbackEthTester {\n    IDepositBoxEth public depositBoxEth;\n    ICommunityPool public communityPool;\n\n    string public schainName;\n\n    bool private _receiveInProgress;\n    bool private _getMyEthInProgress;\n\n    constructor(\n        IDepositBoxEth newDepositBoxEth,\n        ICommunityPool newCommunityPool,\n        string memory newSchainName\n    ) {\n        depositBoxEth = newDepositBoxEth;\n        communityPool = newCommunityPool;\n        schainName = newSchainName;\n    }\n\n    receive() external payable override {\n        if (!_receiveInProgress && !_getMyEthInProgress) {\n            _receiveInProgress = true;\n            uint256 balance = communityPool.getBalance(address(this), schainName);\n            communityPool.withdrawFunds(schainName, balance);\n            _receiveInProgress = false;\n        }\n    }\n\n    function deposit() external payable override {\n        depositBoxEth.deposit{value: msg.value}(schainName);\n    }\n\n    function rechargeUserWallet() external payable override {\n        communityPool.rechargeUserWallet{value: msg.value}(schainName, address(this));\n    }\n\n    function getMyEth() external override {\n        _getMyEthInProgress = true;\n        depositBoxEth.getMyEth();\n        _getMyEthInProgress = false;\n    }\n}"
            },
            "contracts/mainnet/MessageProxyForMainnet.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForMainnet.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IWallets.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/ISchains.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/IMessageProxyForMainnet.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol\";\n\n\nimport \"../MessageProxy.sol\";\nimport \"./SkaleManagerClient.sol\";\nimport \"./CommunityPool.sol\";\n\n\n/**\n * @title Message Proxy for Mainnet\n * @dev Runs on Mainnet, contains functions to manage the incoming messages from\n * `targetSchainName` and outgoing messages to `fromSchainName`. Every SKALE chain with\n * IMA is therefore connected to MessageProxyForMainnet.\n *\n * Messages from SKALE chains are signed using BLS threshold signatures from the\n * nodes in the chain. Since Ethereum Mainnet has no BLS public key, mainnet\n * messages do not need to be signed.\n */\ncontract MessageProxyForMainnet is SkaleManagerClient, MessageProxy, IMessageProxyForMainnet {\n\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    struct Pause {\n        bool paused;\n    }\n\n    bytes32 public constant PAUSABLE_ROLE = keccak256(abi.encodePacked(\"PAUSABLE_ROLE\"));\n\n    /**\n     * 16 Agents\n     * Synchronize time with time.nist.gov\n     * Every agent checks if it is their time slot\n     * Time slots are in increments of 10 seconds\n     * At the start of their slot each agent:\n     * For each connected schain:\n     * Read incoming counter on the dst chain\n     * Read outgoing counter on the src chain\n     * Calculate the difference outgoing - incoming\n     * Call postIncomingMessages function passing (un)signed message array\n     * ID of this schain, Chain 0 represents ETH mainnet,\n    */\n\n    ICommunityPool public communityPool;\n\n    uint256 public headerMessageGasCost;\n    uint256 public messageGasCost;\n\n    // disable detector until slither will fix this issue\n    // https://github.com/crytic/slither/issues/456\n    // slither-disable-next-line uninitialized-state\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _registryContracts;\n    string public version;\n    bool public override messageInProgress;\n\n    // schainHash   => Pause structure\n    mapping(bytes32 => Pause) public pauseInfo;\n\n    //   schainHash => Set of addresses of reimbursed contracts\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _reimbursedContracts;\n\n    /**\n     * @dev Emitted when gas cost for message header was changed.\n     */\n    event GasCostMessageHeaderWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when gas cost for message was changed.\n     */\n    event GasCostMessageWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the schain is paused\n     */\n    event SchainPaused(\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when the schain is resumed\n     */\n    event SchainResumed(\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when reimbursed contract was added\n     */\n    event ReimbursedContractAdded(\n        bytes32 indexed schainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when reimbursed contract was removed\n     */\n    event ReimbursedContractRemoved(\n        bytes32 indexed schainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Reentrancy guard for postIncomingMessages.\n     */\n    modifier messageInProgressLocker() {\n        require(!messageInProgress, \"Message is in progress\");\n        messageInProgress = true;\n        _;\n        messageInProgress = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when IMA is active.\n     */\n    modifier whenNotPaused(bytes32 schainHash) {\n        require(!isPaused(schainHash), \"IMA is paused\");\n        _;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - Schain name must not be `Mainnet`.\n     */\n    function addConnectedChain(string calldata schainName) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(ISchainsInternal(\n            contractManagerOfSkaleManager.getContract(\"SchainsInternal\")\n        ).isSchainExist(schainHash), \"SKALE chain must exist\");\n        _addConnectedChain(schainHash);\n    }\n\n    /**\n     * @dev Allows owner of the contract to set CommunityPool address for gas reimbursement.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as DEFAULT_ADMIN_ROLE.\n     * - Address of CommunityPool contract must not be null.\n     */\n    function setCommunityPool(ICommunityPool newCommunityPoolAddress) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\");\n        require(address(newCommunityPoolAddress) != address(0), \"CommunityPool address has to be set\");\n        communityPool = newCommunityPoolAddress;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Schain name must not be `Mainnet`.\n     */\n    function registerExtraContract(string memory schainName, address extraContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to register extra contract\"\n        );\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");\n        _registerExtraContract(schainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Schain name must not be `Mainnet`.\n     */\n    function removeExtraContract(string memory schainName, address extraContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to register extra contract\"\n        );\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");\n        _removeExtraContract(schainHash, extraContract);\n        if (_reimbursedContracts[schainHash].contains(extraContract)) {\n            _removeReimbursedContract(schainHash, extraContract);\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to add reimbursed contract for being able to reimburse gas amount from CommunityPool\n     * during message transfers from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE or owner of given `schainName`.\n     * - Schain name must not be `Mainnet`.\n     * - `reimbursedContract` should be registered as extra contract\n     */\n    function addReimbursedContract(string memory schainName, address reimbursedContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");        \n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to add reimbursed contract\"\n        );\n        require(reimbursedContract.isContract(), \"Given address is not a contract\");\n        require(isContractRegistered(schainHash, reimbursedContract), \"Contract is not registered\");\n        require(!_reimbursedContracts[schainHash].contains(reimbursedContract), \"Reimbursed contract is already added\");\n        _reimbursedContracts[schainHash].add(reimbursedContract);\n        emit ReimbursedContractAdded(schainHash, reimbursedContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove reimbursed contract,\n     * thus `reimbursedContract` will no longer be available to reimburse gas amount from CommunityPool during\n     * message transfers from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE or owner of given `schainName`.\n     * - Schain name must not be `Mainnet`.\n     */\n    function removeReimbursedContract(string memory schainName, address reimbursedContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");\n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to remove reimbursed contract\"\n        );\n        require(_reimbursedContracts[schainHash].contains(reimbursedContract), \"Reimbursed contract is not added\");\n        _removeReimbursedContract(schainHash, reimbursedContract);\n    }\n\n    /**\n     * @dev Posts incoming message from `fromSchainName`.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be authorized caller.\n     * - `fromSchainName` must be initialized.\n     * - `startingCounter` must be equal to the chain's incoming message counter.\n     * - If destination chain is Mainnet, message signature must be valid.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        override(IMessageProxy, MessageProxy)\n        messageInProgressLocker\n        whenNotPaused(keccak256(abi.encodePacked(fromSchainName)))\n    {\n        uint256 gasTotal = gasleft();\n        bytes32 fromSchainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(isAgentAuthorized(fromSchainHash, msg.sender), \"Agent is not authorized\");\n        require(_checkSchainBalance(fromSchainHash), \"Schain wallet has not enough funds\");\n        require(connectedChains[fromSchainHash].inited, \"Chain is not initialized\");\n        require(messages.length <= MESSAGES_LENGTH, \"Too many messages\");\n        require(\n            startingCounter == connectedChains[fromSchainHash].incomingMessageCounter,\n            \"Starting counter is not equal to incoming message counter\");\n\n        require(_verifyMessages(\n            fromSchainName,\n            _hashedArray(messages, startingCounter, fromSchainName), sign),\n            \"Signature is not verified\");\n        uint additionalGasPerMessage =\n            (gasTotal - gasleft() + headerMessageGasCost + messages.length * messageGasCost) / messages.length;\n        uint notReimbursedGas = 0;\n        connectedChains[fromSchainHash].incomingMessageCounter += messages.length;\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isReimbursedContract(fromSchainHash, messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal - gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal - gasleft() + additionalGasPerMessage;\n            }\n        }\n        communityPool.refundGasBySchainWallet(fromSchainHash, payable(msg.sender), notReimbursedGas);\n    }\n\n    /**\n     * @dev Sets headerMessageGasCost to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as CONSTANT_SETTER_ROLE.\n     */\n    function setNewHeaderMessageGasCost(uint256 newHeaderMessageGasCost) external override onlyConstantSetter {\n        emit GasCostMessageHeaderWasChanged(headerMessageGasCost, newHeaderMessageGasCost);\n        headerMessageGasCost = newHeaderMessageGasCost;\n    }\n\n    /**\n     * @dev Sets messageGasCost to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as CONSTANT_SETTER_ROLE.\n     */\n    function setNewMessageGasCost(uint256 newMessageGasCost) external override onlyConstantSetter {\n        emit GasCostMessageWasChanged(messageGasCost, newMessageGasCost);\n        messageGasCost = newMessageGasCost;\n    }\n\n    /**\n     * @dev Sets new version of contracts on mainnet\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted DEFAULT_ADMIN_ROLE.\n     */\n    function setVersion(string calldata newVersion) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        emit VersionUpdated(version, newVersion);\n        version = newVersion;\n    }\n\n    /**\n     * @dev Allows PAUSABLE_ROLE to pause IMA bridge unlimited\n     *\n     * Requirements:\n     *\n     * - IMA bridge to current schain was not paused\n     * - Sender should be PAUSABLE_ROLE\n     */\n    function pause(string calldata schainName) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(hasRole(PAUSABLE_ROLE, msg.sender), \"Incorrect sender\");\n        require(!pauseInfo[schainHash].paused, \"Already paused\");\n        pauseInfo[schainHash].paused = true;\n        emit SchainPaused(schainHash);\n    }\n\n/**\n     * @dev Allows DEFAULT_ADMIN_ROLE or schain owner to resume IMA bridge\n     *\n     * Requirements:\n     *\n     * - IMA bridge to current schain was paused\n     * - Sender should be DEFAULT_ADMIN_ROLE or schain owner\n     */\n    function resume(string calldata schainName) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender) || isSchainOwner(msg.sender, schainHash), \"Incorrect sender\");\n        require(pauseInfo[schainHash].paused, \"Already unpaused\");\n        pauseInfo[schainHash].paused = false;\n        emit SchainResumed(schainHash);\n    }\n\n    /**\n     * @dev Should return length of reimbursed contracts by schainHash.\n     */\n    function getReimbursedContractsLength(bytes32 schainHash) external view override returns (uint256) {\n        return _reimbursedContracts[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of reimbursed contracts by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getReimbursedContractsRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _reimbursedContracts[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _reimbursedContracts[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Creates a new MessageProxyForMainnet contract.\n     */\n    function initialize(IContractManager contractManagerOfSkaleManagerValue) public virtual override initializer {\n        SkaleManagerClient.initialize(contractManagerOfSkaleManagerValue);\n        MessageProxy.initializeMessageProxy(1e6);\n        headerMessageGasCost = 92251;\n        messageGasCost = 9000;\n    }\n\n    /**\n     * @dev PostOutgoingMessage function with whenNotPaused modifier\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override(IMessageProxy, MessageProxy)\n        whenNotPaused(targetChainHash)\n    {\n        super.postOutgoingMessage(targetChainHash, targetContract, data);\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     *\n     * Note: Mainnet chain does not have a public key, and is implicitly\n     * connected to MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `schainName` must not be Mainnet.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        override(IMessageProxy, MessageProxy)\n        returns (bool)\n    {\n        require(keccak256(abi.encodePacked(schainName)) != MAINNET_HASH, \"Schain id can not be equal Mainnet\");\n        return super.isConnectedChain(schainName);\n    }\n\n    /**\n     * @dev Returns true if IMA to schain is paused.\n     */\n    function isPaused(bytes32 schainHash) public view override returns (bool) {\n        return pauseInfo[schainHash].paused;\n    }\n\n    /**\n     * @dev Returns true if message to the contract should be reimbursed from CommunityPool.\n     */\n    function isReimbursedContract(bytes32 schainHash, address contractAddress) public view override returns (bool) {\n        return\n            isContractRegistered(bytes32(0), contractAddress) ||\n            _reimbursedContracts[schainHash].contains(contractAddress);\n    }\n\n    // private\n\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view override {\n        require(\n            isContractRegistered(bytes32(0), msg.sender)\n                || isContractRegistered(targetChainHash, msg.sender)\n                || isSchainOwner(msg.sender, targetChainHash),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Converts calldata structure to memory structure and checks\n     * whether message BLS signature is valid.\n     */\n    function _verifyMessages(\n        string calldata fromSchainName,\n        bytes32 hashedMessages,\n        MessageProxyForMainnet.Signature calldata sign\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return ISchains(\n            contractManagerOfSkaleManager.getContract(\"Schains\")\n        ).verifySchainSignature(\n            sign.blsSignature[0],\n            sign.blsSignature[1],\n            hashedMessages,\n            sign.counter,\n            sign.hashA,\n            sign.hashB,\n            fromSchainName\n        );\n    }\n\n    /**\n     * @dev Checks whether balance of schain wallet is sufficient for\n     * for reimbursement custom message.\n     */\n    function _checkSchainBalance(bytes32 schainHash) internal view returns (bool) {\n        return IWallets(\n            payable(contractManagerOfSkaleManager.getContract(\"Wallets\"))\n        ).getSchainBalance(schainHash) >= (MESSAGES_LENGTH + 1) * gasLimit * tx.gasprice;\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        override\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage)\n    {\n        return _registryContracts;\n    }\n\n\n    function _removeReimbursedContract(bytes32 schainHash, address reimbursedContract) private {\n        _reimbursedContracts[schainHash].remove(reimbursedContract);\n        emit ReimbursedContractRemoved(schainHash, reimbursedContract);\n    }\n}\n"
            },
            "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
            },
            "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
            },
            "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
            },
            "contracts/mainnet/SkaleManagerClient.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   SkaleManagerClient.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IContractManager.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/ISkaleManagerClient.sol\";\n\n\n/**\n * @title SkaleManagerClient - contract that knows ContractManager\n * and makes calls to SkaleManager contracts.\n */\ncontract SkaleManagerClient is Initializable, AccessControlEnumerableUpgradeable, ISkaleManagerClient {\n\n    IContractManager public contractManagerOfSkaleManager;\n\n    /**\n     * @dev Modifier for checking whether caller is owner of SKALE chain.\n     */\n    modifier onlySchainOwner(string memory schainName) {\n        require(\n            isSchainOwner(msg.sender, _schainHash(schainName)),\n            \"Sender is not an Schain owner\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking whether caller is owner of SKALE chain.\n     */\n    modifier onlySchainOwnerByHash(bytes32 schainHash) {\n        require(\n            isSchainOwner(msg.sender, schainHash),\n            \"Sender is not an Schain owner\"\n        );\n        _;\n    }\n\n    /**\n     * @dev initialize - sets current address of ContractManager of SkaleManager.\n     * @param newContractManagerOfSkaleManager - current address of ContractManager of SkaleManager.\n     */\n    function initialize(\n        IContractManager newContractManagerOfSkaleManager\n    )\n        public\n        override\n        virtual\n        initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        contractManagerOfSkaleManager = newContractManagerOfSkaleManager;\n    }\n\n    /**\n     * @dev Checks whether sender is owner of SKALE chain\n     */\n    function isSchainOwner(address sender, bytes32 schainHash) public view override returns (bool) {\n        address skaleChainsInternal = contractManagerOfSkaleManager.getContract(\"SchainsInternal\");\n        return ISchainsInternal(skaleChainsInternal).isOwnerAddress(sender, schainHash);\n    }\n\n    function isAgentAuthorized(bytes32 schainHash, address sender) public view override returns (bool) {\n        address skaleChainsInternal = contractManagerOfSkaleManager.getContract(\"SchainsInternal\");\n        return ISchainsInternal(skaleChainsInternal).isNodeAddressesInGroup(schainHash, sender);\n    }\n\n    function _schainHash(string memory schainName) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(schainName));\n    }\n}\n"
            },
            "contracts/mainnet/CommunityPool.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    CommunityPool.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n    @author Artem Payvin\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IWallets.sol\";\n\nimport \"../Messages.sol\";\nimport \"./Twin.sol\";\n\n\n/**\n * @title CommunityPool\n * @dev Contract contains logic to perform automatic self-recharging ETH for nodes.\n */\ncontract CommunityPool is Twin, ICommunityPool {\n\n    using AddressUpgradeable for address payable;\n\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n\n    // address of user => schainHash => balance of gas wallet in ETH\n    mapping(address => mapping(bytes32 => uint)) private _userWallets;\n\n    // address of user => schainHash => true if unlocked for transferring\n    mapping(address => mapping(bytes32 => bool)) public activeUsers;\n\n    uint public minTransactionGas;\n\n    uint public multiplierNumerator;\n    uint public multiplierDivider;\n\n    /**\n     * @dev Emitted when minimal value in gas for transactions from schain to mainnet was changed \n     */\n    event MinTransactionGasWasChanged(\n        uint oldValue,\n        uint newValue\n    );\n\n    /**\n     * @dev Emitted when basefee multiplier was changed \n     */\n    event MultiplierWasChanged(\n        uint oldMultiplierNumerator,\n        uint oldMultiplierDivider,\n        uint newMultiplierNumerator,\n        uint newMultiplierDivider\n    );\n\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linker,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        external\n        override\n        initializer\n    {\n        Twin.initialize(contractManagerOfSkaleManagerValue, messageProxyValue);\n        _setupRole(LINKER_ROLE, address(linker));\n        minTransactionGas = 1e6;\n        multiplierNumerator = 3;\n        multiplierDivider = 2;\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet to reimburse gas for transactions \n     * that transfer funds from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - User that receives funds should have enough funds in their gas wallet.\n     * - Address that should be reimbursed for executing transaction must not be null.\n     */\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount > _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                getSchainContract(schainHash),\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n\n    function refundGasBySchainWallet(\n        bytes32 schainHash,\n        address payable node,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (bool)\n    {\n        if (gas > 0) {\n\n            IWallets(payable(contractManagerOfSkaleManager.getContract(\"Wallets\"))).refundGasBySchain(\n                schainHash,\n                node,\n                gas,\n                false\n            );\n        }\n        return true;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to recharge their wallet for further gas reimbursement.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` should recharge their gas wallet for amount that enough to reimburse any \n     *   transaction from schain to mainnet.\n     */\n    function rechargeUserWallet(string calldata schainName, address user) external payable override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            _balanceIsSufficient(schainHash, user, msg.value),\n            \"Not enough ETH for transaction\"\n        );\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] + msg.value;\n        if (!activeUsers[user][schainHash]) {\n            activeUsers[user][schainHash] = true;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                getSchainContract(schainHash),\n                Messages.encodeActivateUserMessage(user)\n            );\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to withdraw funds from their gas wallet.\n     * If `msg.sender` withdraws too much funds,\n     * then he will no longer be able to transfer their tokens on ETH from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function withdrawFunds(string calldata schainName, uint amount) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(amount <= _userWallets[msg.sender][schainHash], \"Balance is too low\");\n        require(!messageProxy.messageInProgress(), \"Message is in progress\");\n        _userWallets[msg.sender][schainHash] = _userWallets[msg.sender][schainHash] - amount;\n        if (\n            !_balanceIsSufficient(schainHash, msg.sender, 0) &&\n            activeUsers[msg.sender][schainHash]\n        ) {\n            activeUsers[msg.sender][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                getSchainContract(schainHash),\n                Messages.encodeLockUserMessage(msg.sender)\n            );\n        }\n        payable(msg.sender).sendValue(amount);\n    }\n\n    /**\n     * @dev Allows `msg.sender` set the amount of gas that should be \n     * enough for reimbursing any transaction from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function setMinTransactionGas(uint newMinTransactionGas) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"CONSTANT_SETTER_ROLE is required\");\n        emit MinTransactionGasWasChanged(minTransactionGas, newMinTransactionGas);\n        minTransactionGas = newMinTransactionGas;\n    }\n\n    /**\n     * @dev Allows `msg.sender` set the amount of gas that should be \n     * enough for reimbursing any transaction from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function setMultiplier(uint newMultiplierNumerator, uint newMultiplierDivider) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"CONSTANT_SETTER_ROLE is required\");\n        require(newMultiplierDivider > 0, \"Divider is zero\");\n        emit MultiplierWasChanged(\n            multiplierNumerator,\n            multiplierDivider,\n            newMultiplierNumerator,\n            newMultiplierDivider\n        );\n        multiplierNumerator = newMultiplierNumerator;\n        multiplierDivider = newMultiplierDivider;\n    }\n\n    /**\n     * @dev Returns the amount of ETH on gas wallet for particular user.\n     */\n    function getBalance(address user, string calldata schainName) external view override returns (uint) {\n        return _userWallets[user][keccak256(abi.encodePacked(schainName))];\n    }\n\n    /**\n     * @dev Checks whether user is active and wallet was recharged for sufficient amount.\n     */\n    function checkUserBalance(bytes32 schainHash, address receiver) external view override returns (bool) {\n        return activeUsers[receiver][schainHash] && _balanceIsSufficient(schainHash, receiver, 0);\n    }\n\n    /**\n     * @dev Checks whether passed amount is enough to recharge user wallet with current basefee.\n     */\n    function getRecommendedRechargeAmount(\n        bytes32 schainHash,\n        address receiver\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentValue = _multiplyOnAdaptedBaseFee(minTransactionGas);\n        if (currentValue  <= _userWallets[receiver][schainHash]) {\n            return 0;\n        }\n        return currentValue - _userWallets[receiver][schainHash];\n    }\n\n    /**\n     * @dev Checks whether user wallet was recharged for sufficient amount.\n     */\n    function _balanceIsSufficient(bytes32 schainHash, address receiver, uint256 delta) private view returns (bool) {\n        return delta + _userWallets[receiver][schainHash] >= minTransactionGas * tx.gasprice;\n    }\n\n    function _multiplyOnAdaptedBaseFee(uint256 value) private view returns (uint256) {\n        return value * block.basefee * multiplierNumerator / multiplierDivider;\n    }\n}\n"
            },
            "contracts/mainnet/Twin.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Twin.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *   @author Vadim Yavorsky\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/ITwin.sol\";\n\nimport \"./MessageProxyForMainnet.sol\";\nimport \"./SkaleManagerClient.sol\";\n\n/**\n * @title Twin\n * @dev Runs on Mainnet,\n * contains logic for connecting paired contracts on Mainnet and on Schain.\n */\nabstract contract Twin is SkaleManagerClient, ITwin {\n\n    IMessageProxyForMainnet public messageProxy;\n    mapping(bytes32 => address) public schainLinks;\n    bytes32 public constant LINKER_ROLE = keccak256(\"LINKER_ROLE\");\n\n    /**\n     * @dev Modifier for checking whether caller is MessageProxy contract.\n     */\n    modifier onlyMessageProxy() {\n        require(msg.sender == address(messageProxy), \"Sender is not a MessageProxy\");\n        _;\n    }\n\n    /**\n     * @dev Binds a contract on mainnet with their twin on schain.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be schain owner or has required role.\n     * - SKALE chain must not already be added.\n     * - Address of contract on schain must be non-zero.\n     */\n    function addSchainContract(string calldata schainName, address contractReceiver) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(LINKER_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash), \"Not authorized caller\"\n        );\n        require(schainLinks[schainHash] == address(0), \"SKALE chain is already set\");\n        require(contractReceiver != address(0), \"Incorrect address of contract receiver on Schain\");\n        schainLinks[schainHash] = contractReceiver;\n    }\n\n    /**\n     * @dev Removes connection with contract on schain.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be schain owner or has required role.\n     * - SKALE chain must already be set.\n     */\n    function removeSchainContract(string calldata schainName) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(LINKER_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash), \"Not authorized caller\"\n        );\n        require(schainLinks[schainHash] != address(0), \"SKALE chain is not set\");\n        delete schainLinks[schainHash];\n    }\n\n    /**\n     * @dev Returns true if mainnet contract and schain contract are connected together for transferring messages.\n     */\n    function hasSchainContract(string calldata schainName) external view override returns (bool) {\n        return schainLinks[keccak256(abi.encodePacked(schainName))] != address(0);\n    }\n    \n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        IMessageProxyForMainnet newMessageProxy\n    )\n        public\n        virtual\n        initializer\n    {\n        SkaleManagerClient.initialize(contractManagerOfSkaleManagerValue);\n        messageProxy = newMessageProxy;\n    }\n\n    function getSchainContract(bytes32 schainHash) public override view returns (address) {\n        require(\n            schainLinks[schainHash] != address(0),\n            \"Destination contract must be defined\"\n        );\n        return schainLinks[schainHash];\n    }\n}\n"
            },
            "contracts/test/MessageProxyForMainnetTester.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForSchainTester.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"../mainnet/MessageProxyForMainnet.sol\";\n\n\ninterface IMessageProxyForMainnetTester {\n    function refundGasByUser(\n        bytes32 fromSchainHash,\n        address payable node,\n        address user,\n        uint256 gas\n    ) external;\n}\n\n\ncontract MessageProxyForMainnetTester is MessageProxyForMainnet, IMessageProxyForMainnetTester {    \n\n    function refundGasByUser(\n        bytes32 fromSchainHash,\n        address payable node,\n        address user,\n        uint256 gas\n    )\n        external\n        override\n    {\n        communityPool.refundGasByUser(fromSchainHash, node, user, gas);\n    }\n}\n"
            },
            "contracts/test/MessageProxyCaller.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyCaller.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"../mainnet/MessageProxyForMainnet.sol\";\nimport \"../schain/MessageProxyForSchain.sol\";\n\n\ninterface IMessageProxyCaller {\n    function postOutgoingMessageTester(\n        MessageProxyForMainnet messageProxyForMainnet,\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes calldata data\n    ) external;\n    function postOutgoingMessageTesterOnSchain(\n        MessageProxyForSchain messageProxyForSchain,\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes calldata data\n    ) external;\n}\n\n\ncontract MessageProxyCaller is IMessageProxyCaller {    \n\n    function postOutgoingMessageTester(\n        MessageProxyForMainnet messageProxyForMainnet,\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes calldata data\n    )\n        external\n        override\n    {\n        messageProxyForMainnet.postOutgoingMessage(targetChainHash, targetContract, data);\n    }\n\n    function postOutgoingMessageTesterOnSchain(\n        MessageProxyForSchain messageProxyForSchain,\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes calldata data\n    )\n        external\n        override\n    {\n        messageProxyForSchain.postOutgoingMessage(targetChainHash, targetContract, data);\n    }\n}"
            },
            "contracts/test/MessageProxyForSchainTester.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForSchainTester.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"../schain/MessageProxyForSchain.sol\";\n\n\ninterface IMessageProxyForSchainTester {\n    function postMessage(\n        IMessageReceiver targetContract,\n        bytes32 fromSchainHash,\n        address sender,\n        bytes calldata data\n    )\n    external;\n    function postOutgoingMessageTester(\n        MessageProxyForSchain targetContract,\n        bytes32 targetChainHash,\n        address dstContract,\n        bytes calldata data\n    )\n    external;\n    function setEtherbase(IEtherbaseUpgradeable etherbaseAddress) external;\n}\n\n\ncontract MessageProxyForSchainTester is MessageProxyForSchain, IMessageProxyForSchainTester {    \n\n    IEtherbaseUpgradeable public etherbase = ETHERBASE;\n\n    constructor(IKeyStorage _keyStorage, string memory schainName) {\n        MessageProxyForSchain.initialize(_keyStorage, schainName);\n    }\n\n    function postMessage(\n        IMessageReceiver targetContract,\n        bytes32 fromSchainHash,\n        address sender,\n        bytes calldata data\n    )\n    external\n    override\n    {\n        targetContract.postMessage(fromSchainHash, sender, data);\n    }\n\n    function postOutgoingMessageTester(\n        MessageProxyForSchain targetContract,\n        bytes32 targetChainHash,\n        address dstContract,\n        bytes calldata data\n    )\n    external\n    override\n    {\n        targetContract.postOutgoingMessage(targetChainHash, dstContract, data);\n    }\n\n    function setEtherbase(IEtherbaseUpgradeable etherbaseAddress) external override {\n        etherbase = etherbaseAddress;\n    }\n\n    function _getEtherbase() internal view override returns (IEtherbaseUpgradeable) {\n        return etherbase;\n    }\n}"
            },
            "contracts/test/MessageProxyForSchainWithoutSignature.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForSchainWithoutSignature.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"./MessageProxyForSchainTester.sol\";\n\ncontract MessageProxyForSchainWithoutSignature is MessageProxyForSchainTester {\n\n    constructor(string memory schainName) MessageProxyForSchainTester(IKeyStorage(address(0)), schainName)\n    // solhint-disable-next-line no-empty-blocks\n    {}\n\n    function _verifyMessages(\n        bytes32,\n        Signature calldata\n    )\n        internal\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n}\n"
            },
            "contracts/mainnet/Linker.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Linker.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/ILinker.sol\";\n\nimport \"../Messages.sol\";\nimport \"./MessageProxyForMainnet.sol\";\nimport \"./Twin.sol\";\n\n\n/**\n * @title Linker For Mainnet\n * @dev Runs on Mainnet,\n * links contracts on mainnet with their twin on schain,\n * allows to kill schain when interchain connection was not enabled.\n */\ncontract Linker is Twin, ILinker {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    enum KillProcess {NotKilled, PartiallyKilledBySchainOwner, PartiallyKilledByContractOwner, Killed}\n    EnumerableSetUpgradeable.AddressSet private _mainnetContracts;\n\n    // Deprecated variable\n    mapping(bytes32 => bool) private _interchainConnections;\n    //\n\n    // schainHash => schain status of killing process \n    mapping(bytes32 => KillProcess) public statuses;\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {LINKER_ROLE}.\n     */\n    modifier onlyLinker() {\n        require(hasRole(LINKER_ROLE, msg.sender), \"Linker role is required\");\n        _;\n    }\n\n    /**\n     * @dev Allows Linker to register external mainnet contracts.\n     * \n     * Requirements:\n     * \n     * - Contract must be not registered.\n     */\n    function registerMainnetContract(address newMainnetContract) external override onlyLinker {\n        require(_mainnetContracts.add(newMainnetContract), \"The contracts was not registered\");\n    }\n\n    /**\n     * @dev Allows Linker to remove external mainnet contracts.\n     * \n     * Requirements:\n     * \n     * - Contract must be registered.\n     */\n    function removeMainnetContract(address mainnetContract) external override onlyLinker {\n        require(_mainnetContracts.remove(mainnetContract), \"The contract was not removed\");\n    }\n\n    /**\n     * @dev Allows Linker to connect mainnet contracts with their receivers on schain.\n     * \n     * Requirements:\n     * \n     * - Numbers of mainnet contracts and schain contracts must be equal.\n     * - Mainnet contract must implement method `addSchainContract`.\n     */\n    function connectSchain(\n        string calldata schainName,\n        address[] calldata schainContracts\n    )\n        external\n        override\n        onlyLinker\n    {\n        require(schainContracts.length == _mainnetContracts.length(), \"Incorrect number of addresses\");\n        for (uint i = 0; i < schainContracts.length; i++) {\n            Twin(_mainnetContracts.at(i)).addSchainContract(schainName, schainContracts[i]);\n        }\n        messageProxy.addConnectedChain(schainName);\n    }\n\n    /**\n     * @dev Allows Schain owner and contract deployer to kill schain. \n     * To kill the schain, both entities must call this function, and the order is not important.\n     * \n     * Requirements:\n     * \n     * - Interchain connection should be turned off.\n     */\n    function kill(string calldata schainName) override external {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        if (statuses[schainHash] == KillProcess.NotKilled) {\n            if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n                statuses[schainHash] = KillProcess.PartiallyKilledByContractOwner;\n            } else if (isSchainOwner(msg.sender, schainHash)) {\n                statuses[schainHash] = KillProcess.PartiallyKilledBySchainOwner;\n            } else {\n                revert(\"Not allowed\");\n            }\n        } else if (\n            (\n                statuses[schainHash] == KillProcess.PartiallyKilledBySchainOwner &&\n                hasRole(DEFAULT_ADMIN_ROLE, msg.sender)\n            ) || (\n                statuses[schainHash] == KillProcess.PartiallyKilledByContractOwner &&\n                isSchainOwner(msg.sender, schainHash)\n            )\n        ) {\n            statuses[schainHash] = KillProcess.Killed;\n        } else {\n            revert(\"Already killed or incorrect sender\");\n        }\n    }\n\n    /**\n     * @dev Allows Linker disconnect schain from the network. This will remove all receiver contracts on schain.\n     * Thus, messages will not go from the mainnet to the schain.\n     * \n     * Requirements:\n     * \n     * - Mainnet contract should implement method `removeSchainContract`.\n     */\n    function disconnectSchain(string calldata schainName) external override onlyLinker {\n        uint length = _mainnetContracts.length();\n        for (uint i = 0; i < length; i++) {\n            Twin(_mainnetContracts.at(i)).removeSchainContract(schainName);\n        }\n        messageProxy.removeConnectedChain(schainName);\n    }\n\n    /**\n     * @dev Returns true if schain is not killed.\n     */\n    function isNotKilled(bytes32 schainHash) external view override returns (bool) {\n        return statuses[schainHash] != KillProcess.Killed;\n    }\n\n    /**\n     * @dev Returns true if list of mainnet contracts has particular contract.\n     */\n    function hasMainnetContract(address mainnetContract) external view override returns (bool) {\n        return _mainnetContracts.contains(mainnetContract);\n    }\n\n    /**\n     * @dev Returns true if mainnet contracts and schain contracts are connected together for transferring messages.\n     */\n    function hasSchain(string calldata schainName) external view override returns (bool connected) {\n        uint length = _mainnetContracts.length();\n        connected = messageProxy.isConnectedChain(schainName);\n        for (uint i = 0; connected && i < length; i++) {\n            connected = connected && Twin(_mainnetContracts.at(i)).hasSchainContract(schainName);\n        }\n    }\n\n    /**\n     * @dev Create a new Linker contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override\n        initializer\n    {\n        Twin.initialize(contractManagerOfSkaleManagerValue, messageProxyValue);\n        _setupRole(LINKER_ROLE, msg.sender);\n        _setupRole(LINKER_ROLE, address(this));\n\n        // fake usage of variable\n        delete _interchainConnections[bytes32(0)];\n    }\n}\n"
            },
            "contracts/mainnet/DepositBox.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBox.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/IDepositBox.sol\";\n\nimport \"./Twin.sol\";\n\n\n/**\n * @title DepositBox\n * @dev Abstract contracts for DepositBoxes on mainnet.\n */\nabstract contract DepositBox is IDepositBox, Twin {\n\n    ILinker public linker;\n\n    // schainHash => true if automatic deployment tokens on schain was enabled \n    mapping(bytes32 => bool) private _automaticDeploy;\n\n    bytes32 public constant DEPOSIT_BOX_MANAGER_ROLE = keccak256(\"DEPOSIT_BOX_MANAGER_ROLE\");\n\n    /**\n     * @dev Modifier for checking whether schain was not killed.\n     */\n    modifier whenNotKilled(bytes32 schainHash) {\n        require(linker.isNotKilled(schainHash), \"Schain is killed\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking whether schain was killed.\n     */\n    modifier whenKilled(bytes32 schainHash) {\n        require(!linker.isNotKilled(schainHash), \"Schain is not killed\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking whether schainName is not equal to `Mainnet` \n     * and address of receiver is not equal to null before transferring funds from mainnet to schain.\n     */\n    modifier rightTransaction(string memory schainName, address to) {\n        require(\n            keccak256(abi.encodePacked(schainName)) != keccak256(abi.encodePacked(\"Mainnet\")),\n            \"SKALE chain name cannot be Mainnet\"\n        );\n        require(to != address(0), \"Receiver address cannot be null\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking whether schainHash is not equal to `Mainnet` \n     * and sender contract was added as contract processor on schain.\n     */\n    modifier checkReceiverChain(bytes32 schainHash, address sender) {\n        require(\n            schainHash != keccak256(abi.encodePacked(\"Mainnet\")) &&\n            sender == schainLinks[schainHash],\n            \"Receiver chain is incorrect\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Allows Schain owner turn on whitelist of tokens.\n     */\n    function enableWhitelist(string memory schainName) external override onlySchainOwner(schainName) {\n        _automaticDeploy[keccak256(abi.encodePacked(schainName))] = false;\n    }\n\n    /**\n     * @dev Allows Schain owner turn off whitelist of tokens.\n     */\n    function disableWhitelist(string memory schainName) external override onlySchainOwner(schainName) {\n        _automaticDeploy[keccak256(abi.encodePacked(schainName))] = true;\n    }\n\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker newLinker,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override\n        virtual\n        initializer\n    {\n        Twin.initialize(contractManagerOfSkaleManagerValue, messageProxyValue);\n        _setupRole(LINKER_ROLE, address(newLinker));\n        linker = newLinker;\n    }\n\n    /**\n     * @dev Returns is whitelist enabled on schain.\n     */\n    function isWhitelisted(string memory schainName) public view override returns (bool) {\n        return !_automaticDeploy[keccak256(abi.encodePacked(schainName))];\n    }\n}\n"
            },
            "contracts/mainnet/DepositBoxes/DepositBoxEth.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxEth.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxEth.sol\";\n\nimport \"../DepositBox.sol\";\nimport \"../../Messages.sol\";\n\n/**\n * @title DepositBoxEth\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ETH.\n */\ncontract DepositBoxEth is DepositBox, IDepositBoxEth {\n    using AddressUpgradeable for address payable;\n\n    mapping(address => uint256) public approveTransfers;\n\n    mapping(bytes32 => uint256) public transferredAmount;\n\n    mapping(bytes32 => bool) public activeEthTransfers;\n\n    event ActiveEthTransfers(bytes32 indexed schainHash, bool active);\n\n    receive() external payable override {\n        revert(\"Use deposit function\");\n    }\n\n    /**\n     * @dev Allows `msg.sender` to send ETH from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Schain name must not be `Mainnet`.\n     * - Receiver contract should be added as twin contract on schain.\n     * - Schain that receives tokens should not be killed.\n     */\n    function deposit(string memory schainName)\n        external\n        payable\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        _saveTransferredAmount(schainHash, msg.value);\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            Messages.encodeTransferEthMessage(msg.sender, msg.value)\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC20 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the eth came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - Amount of eth on DepositBoxEth should be equal or more than transferred amount.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n    {\n        Messages.TransferEthMessage memory message = Messages.decodeTransferEthMessage(data);\n        require(\n            message.amount <= address(this).balance,\n            \"Not enough money to finish this transaction\"\n        );\n        _removeTransferredAmount(schainHash, message.amount);\n        if (!activeEthTransfers[schainHash]) {\n            approveTransfers[message.receiver] += message.amount;\n        } else {\n            payable(message.receiver).sendValue(message.amount);\n        }\n    }\n\n    /**\n     * @dev Transfers a user's ETH.\n     *\n     * Requirements:\n     *\n     * - DepositBoxETh must have sufficient ETH.\n     * - User must be approved for ETH transfer.\n     */\n    function getMyEth() external override {\n        require(approveTransfers[msg.sender] > 0, \"User has insufficient ETH\");\n        uint256 amount = approveTransfers[msg.sender];\n        approveTransfers[msg.sender] = 0;\n        payable(msg.sender).sendValue(amount);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their ETH.\n     *\n     * Requirements:\n     *\n     * - Amount of ETH on schain should be equal or more than transferred amount.\n     * - Receiver address must not be null.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(string calldata schainName, address payable receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        require(receiver != address(0), \"Receiver address has to be set\");\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(transferredAmount[schainHash] >= amount, \"Incorrect amount\");\n        _removeTransferredAmount(schainHash, amount);\n        receiver.sendValue(amount);\n    }\n\n    /**\n     * @dev Allows Schain owner to switch on or switch off active eth transfers.\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function enableActiveEthTransfers(string calldata schainName)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(!activeEthTransfers[schainHash], \"Active eth transfers enabled\");\n        emit ActiveEthTransfers(schainHash, true);\n        activeEthTransfers[schainHash] = true;\n    }\n\n    /**\n     * @dev Allows Schain owner to switch on or switch off active eth transfers.\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function disableActiveEthTransfers(string calldata schainName)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(activeEthTransfers[schainHash], \"Active eth transfers disabled\");\n        emit ActiveEthTransfers(schainHash, false);\n        activeEthTransfers[schainHash] = false;\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferEthMessage memory message = Messages.decodeTransferEthMessage(data);\n        return message.receiver;\n    }\n\n    /**\n     * @dev Creates a new DepositBoxEth contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,        \n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n    }\n\n    /**\n     * @dev Saves amount of ETH that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 schainHash, uint256 amount) private {\n        transferredAmount[schainHash] += amount;\n    }\n\n    /**\n     * @dev Removes amount of ETH that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 schainHash, uint256 amount) private {\n        transferredAmount[schainHash] -= amount;\n    }\n}\n"
            },
            "contracts/mainnet/DepositBoxes/DepositBoxERC721.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC721.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../DepositBox.sol\";\nimport \"../../Messages.sol\";\n\n\n/**\n * @title DepositBoxERC721\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC721.\n */\ncontract DepositBoxERC721 is DepositBox, IDepositBoxERC721 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // schainHash => address of ERC on Mainnet\n    // Deprecated\n    // slither-disable-next-line unused-state\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedSchainToERC721;\n    mapping(address => mapping(uint256 => bytes32)) public transferredAmount;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC721;\n\n    /**\n     * @dev Emitted when token is mapped in DepositBoxERC721.\n     */\n    event ERC721TokenAdded(string schainName, address indexed contractOnMainnet);\n\n    /**\n     * @dev Emitted when token is received by DepositBox and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC721TokenReady(address indexed contractOnMainnet, uint256 tokenId);\n\n    /**\n     * @dev Allows `msg.sender` to send ERC721 token from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their token for DepositBoxERC721 address.\n     */\n    function depositERC721(\n        string calldata schainName,\n        address erc721OnMainnet,\n        uint256 tokenId\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            IERC721Upgradeable(erc721OnMainnet).getApproved(tokenId) == address(this),\n            \"DepositBox was not approved for ERC721 token\"\n        );\n        bytes memory data = _receiveERC721(\n            schainName,\n            erc721OnMainnet,\n            msg.sender,\n            tokenId\n        );\n        _saveTransferredAmount(schainHash, erc721OnMainnet, tokenId);\n        IERC721Upgradeable(erc721OnMainnet).transferFrom(msg.sender, address(this), tokenId);\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC721 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - DepositBoxERC721 contract should own token.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        virtual\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n    {\n        Messages.TransferErc721Message memory message = Messages.decodeTransferErc721Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(IERC721Upgradeable(message.token).ownerOf(message.tokenId) == address(this), \"Incorrect tokenId\");\n        _removeTransferredAmount(message.token, message.tokenId);\n        IERC721Upgradeable(message.token).transferFrom(address(this), message.receiver, message.tokenId);\n    }\n\n    /**\n     * @dev Allows Schain owner to add an ERC721 token to DepositBoxERC721.\n     * \n     * Emits an {ERC721TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Schain should not be killed.\n     * - Only owner of the schain able to run function.\n     */\n    function addERC721TokenByOwner(string calldata schainName, address erc721OnMainnet)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        _addERC721ForSchain(schainName, erc721OnMainnet);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their tokens.\n     * The Schain owner decides which tokens to send to which address, \n     * since the contract on mainnet does not store information about which tokens belong to whom.\n     *\n     * Requirements:\n     * \n     * - DepositBoxERC721 contract should own such token.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(string calldata schainName, address erc721OnMainnet, address receiver, uint tokenId)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(transferredAmount[erc721OnMainnet][tokenId] == schainHash, \"Incorrect tokenId\");\n        _removeTransferredAmount(erc721OnMainnet, tokenId);\n        IERC721Upgradeable(erc721OnMainnet).transferFrom(address(this), receiver, tokenId);\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        virtual\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc721Message memory message = Messages.decodeTransferErc721Message(data);\n        return message.receiver;\n    }\n\n    /**\n     * @dev Should return length of a set of all mapped tokens which were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC721Length(string calldata schainName) external view override returns (uint256) {\n        return _schainToERC721[keccak256(abi.encodePacked(schainName))].length();\n    }\n\n    /**\n     * @dev Should return an array of range of tokens were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC721(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory tokensInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _schainToERC721[keccak256(abi.encodePacked(schainName))].length(),\n            \"Range is incorrect\"\n        );\n        tokensInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            tokensInRange[i - from] = _schainToERC721[keccak256(abi.encodePacked(schainName))].at(i);\n        }\n    }\n\n    /**\n     * @dev Creates a new DepositBoxERC721 contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,        \n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n    }\n\n    /**\n     * @dev Should return true if token was added by Schain owner or \n     * automatically added after sending to schain if whitelist was turned off.\n     */\n    function getSchainToERC721(\n        string calldata schainName,\n        address erc721OnMainnet\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _schainToERC721[keccak256(abi.encodePacked(schainName))].contains(erc721OnMainnet);\n    }\n\n    /**\n     * @dev Removes the ids of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(address erc721Token, uint256 tokenId) internal {\n        transferredAmount[erc721Token][tokenId] = bytes32(0);\n    }\n\n    /**\n     * @dev Allows DepositBoxERC721 to receive ERC721 tokens.\n     * \n     * Emits an {ERC721TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC721.\n     */\n    function _receiveERC721(\n        string calldata schainName,\n        address erc721OnMainnet,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        virtual\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        bool isERC721AddedToSchain = _schainToERC721[schainHash].contains(erc721OnMainnet);\n        if (!isERC721AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC721ForSchain(schainName, erc721OnMainnet);\n            data = Messages.encodeTransferErc721AndTokenInfoMessage(\n                erc721OnMainnet,\n                to,\n                tokenId,\n                _getTokenInfo(IERC721MetadataUpgradeable(erc721OnMainnet))\n            );\n        } else {\n            data = Messages.encodeTransferErc721Message(erc721OnMainnet, to, tokenId);\n        }\n        emit ERC721TokenReady(erc721OnMainnet, tokenId);\n    }\n\n    /**\n     * @dev Adds an ERC721 token to DepositBoxERC721.\n     * \n     * Emits an {ERC721TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC721ForSchain(string calldata schainName, address erc721OnMainnet) internal {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(erc721OnMainnet.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC721[schainHash].contains(erc721OnMainnet), \"ERC721 Token was already added\");\n        _schainToERC721[schainHash].add(erc721OnMainnet);\n        emit ERC721TokenAdded(schainName, erc721OnMainnet);\n    }\n\n    /**\n     * @dev Returns info about ERC721 token such as token name, symbol.\n     */\n    function _getTokenInfo(IERC721MetadataUpgradeable erc721) internal view returns (Messages.Erc721TokenInfo memory) {\n        return Messages.Erc721TokenInfo({\n            name: erc721.name(),\n            symbol: erc721.symbol()\n        });\n    }\n\n    /**\n     * @dev Saves the ids of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 schainHash, address erc721Token, uint256 tokenId) private {\n        transferredAmount[erc721Token][tokenId] = schainHash;\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC721.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IDepositBoxERC721.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IDepositBox.sol\";\n\n\ninterface IDepositBoxERC721 is IDepositBox {\n    function depositERC721(string calldata schainName, address erc721OnMainnet, uint256 tokenId) external;\n    function addERC721TokenByOwner(string calldata schainName, address erc721OnMainnet) external;\n    function getFunds(string calldata schainName, address erc721OnMainnet, address receiver, uint tokenId) external;\n    function getSchainToERC721(string calldata schainName, address erc721OnMainnet) external view returns (bool);\n    function getSchainToAllERC721Length(string calldata schainName) external view returns (uint256);\n    function getSchainToAllERC721(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        returns (address[] memory);\n}"
            },
            "contracts/mainnet/DepositBoxes/DepositBoxERC721WithMetadata.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC721WithMetadata.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./DepositBoxERC721.sol\";\nimport \"../../Messages.sol\";\n\n/**\n * @title DepositBoxERC721WithMetadata\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC721.\n */\ncontract DepositBoxERC721WithMetadata is DepositBoxERC721 {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC721 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - DepositBoxERC721 contract should own token.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n    {\n        Messages.TransferErc721MessageWithMetadata memory message =\n            Messages.decodeTransferErc721MessageWithMetadata(data);\n        require(message.erc721message.token.isContract(), \"Given address is not a contract\");\n        require(\n            IERC721Upgradeable(message.erc721message.token).ownerOf(message.erc721message.tokenId) == address(this),\n            \"Incorrect tokenId\"\n        );\n        _removeTransferredAmount(message.erc721message.token, message.erc721message.tokenId);\n        IERC721Upgradeable(message.erc721message.token).transferFrom(\n            address(this),\n            message.erc721message.receiver,\n            message.erc721message.tokenId\n        );\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc721MessageWithMetadata memory message =\n            Messages.decodeTransferErc721MessageWithMetadata(data);\n        return message.erc721message.receiver;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC721 to receive ERC721 tokens.\n     * \n     * Emits an {ERC721TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC721.\n     */\n    function _receiveERC721(\n        string calldata schainName,\n        address erc721OnMainnet,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        override\n        returns (bytes memory data)\n    {\n        bool isERC721AddedToSchain = getSchainToERC721(schainName, erc721OnMainnet);\n        if (!isERC721AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC721ForSchain(schainName, erc721OnMainnet);\n            data = Messages.encodeTransferErc721WithMetadataAndTokenInfoMessage(\n                erc721OnMainnet,\n                to,\n                tokenId,\n                _getTokenURI(IERC721MetadataUpgradeable(erc721OnMainnet), tokenId),\n                _getTokenInfo(IERC721MetadataUpgradeable(erc721OnMainnet))\n            );\n        } else {\n            data = Messages.encodeTransferErc721MessageWithMetadata(\n                erc721OnMainnet,\n                to,\n                tokenId,\n                _getTokenURI(IERC721MetadataUpgradeable(erc721OnMainnet), tokenId)\n            );\n        }\n        emit ERC721TokenReady(erc721OnMainnet, tokenId);\n    }\n\n    /**\n     * @dev Returns tokenURI of ERC721 token.\n     */\n    function _getTokenURI(IERC721MetadataUpgradeable erc721, uint256 tokenId) private view returns (string memory) {\n        return erc721.tokenURI(tokenId);\n    }\n\n}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
            },
            "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
            },
            "contracts/schain/TokenManagers/TokenManagerERC1155.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC1155.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC1155OnChain.sol\";\nimport \"../TokenManager.sol\";\nimport \"../../thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol\";\n\n\n/**\n * @title TokenManagerERC1155\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC1155 clones.\n * TokenManagerERC1155 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC1155 is\n    TokenManager,\n    ERC1155ReceiverUpgradeableWithoutGap,\n    ITokenManagerERC1155\n{\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC1155 on Mainnet => ERC1155 on Schain\n    mapping(address => ERC1155OnChain) public deprecatedClonesErc1155;\n\n    // address clone on schain => added or not\n    mapping(ERC1155OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC1155OnChain)) public clonesErc1155;\n\n    mapping(bytes32 => mapping(address => mapping(uint256 => uint256))) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC1155;\n\n    /**\n     * @dev Emitted when schain owner register new ERC1155 clone.\n     */\n    event ERC1155TokenAdded(\n        bytes32 indexed chainHash,\n        address indexed erc1155OnMainnet,\n        address indexed erc1155OnSchain\n    );\n\n    /**\n     * @dev Emitted when TokenManagerERC1155 automatically deploys new ERC1155 clone.\n     */\n    event ERC1155TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc1155OnMainnet,\n        address indexed erc1155OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC1155TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc1155OnMainnet,\n        address indexed erc1155OnSchain,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC1155TokenReady(\n        bytes32 indexed chainHash,\n        address indexed contractOnMainnet,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {to} address.\n     */\n    function exitToMainERC1155(\n        address contractOnMainnet,\n        uint256 id,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(MAINNET_HASH, msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, id, amount);\n    }\n\n    /**\n     * @dev Move batch of tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {to} address.\n     */\n    function exitToMainERC1155Batch(\n        address contractOnMainnet,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(MAINNET_HASH, msg.sender);\n        _exitBatch(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, ids, amounts);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {to} address.\n     */\n    function transferToSchainERC1155(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 id,\n        uint256 amount\n    ) \n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        communityLocker.checkAllowedToSendMessage(targetSchainHash, msg.sender);\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, id, amount);\n    }\n\n    /**\n     * @dev Move batch of tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {to} address.\n     */\n    function transferToSchainERC1155Batch(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) \n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        communityLocker.checkAllowedToSendMessage(targetSchainHash, msg.sender);\n        _exitBatch(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, ids, amounts);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManagerERC1155 addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC1155 ||\n            operation == Messages.MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO\n        ) {\n            receiver = _sendERC1155(fromChainHash, data);\n        } else if (\n            operation == Messages.MessageType.TRANSFER_ERC1155_BATCH ||\n            operation == Messages.MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO\n        ) {\n            receiver = _sendERC1155Batch(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC1155 token clone in the token manager.\n     */\n    function addERC1155TokenByOwner(\n        string calldata targetChainName,\n        address erc1155OnMainnet,\n        address erc1155OnSchain\n    )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc1155OnSchain.isContract(), \"Given address is not a contract\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc1155[targetChainHash][erc1155OnMainnet]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC1155OnChain(erc1155OnSchain)], \"Clone was already added\");\n        clonesErc1155[targetChainHash][erc1155OnMainnet] = ERC1155OnChain(erc1155OnSchain);\n        addedClones[ERC1155OnChain(erc1155OnSchain)] = true;\n        emit ERC1155TokenAdded(targetChainHash, erc1155OnMainnet, erc1155OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override\n        initializer\n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    function onERC1155Received(\n        address operator,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns(bytes4)\n    {\n        require(operator == address(this), \"Revert ERC1155 transfer\");\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns(bytes4)\n    {\n        require(operator == address(this), \"Revert ERC1155 batch transfer\");\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }\n\n    /**\n     * @dev Checks whether contract supports such interface (first 4 bytes of method name and its params).\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(AccessControlEnumerableUpgradeable, ERC1155ReceiverUpgradeableWithoutGap)\n        returns (bool)\n    {\n        return interfaceId == type(TokenManager).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n\n    /**\n     * @dev Allows TokenManager to send ERC1155 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC1155(bytes32 fromChainHash, bytes calldata data) private returns (address) {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        address receiver;\n        address token;\n        uint256 id;\n        uint256 amount;\n        ERC1155OnChain contractOnSchain;\n        if (messageType == Messages.MessageType.TRANSFER_ERC1155){\n            Messages.TransferErc1155Message memory message = Messages.decodeTransferErc1155Message(data);\n            receiver = message.receiver;\n            token = message.token;\n            id = message.id;\n            amount = message.amount;\n            contractOnSchain = clonesErc1155[fromChainHash][token];\n        } else {\n            Messages.TransferErc1155AndTokenInfoMessage memory message =\n                Messages.decodeTransferErc1155AndTokenInfoMessage(data);\n            receiver = message.baseErc1155transfer.receiver;\n            token = message.baseErc1155transfer.token;\n            id = message.baseErc1155transfer.id;\n            amount = message.baseErc1155transfer.amount;\n            contractOnSchain = clonesErc1155[fromChainHash][token];\n            if (address(contractOnSchain) == address(0)) {\n                require(automaticDeploy, \"Automatic deploy is disabled\");\n                contractOnSchain = new ERC1155OnChain(message.tokenInfo.uri);\n                clonesErc1155[fromChainHash][token] = contractOnSchain;\n                addedClones[contractOnSchain] = true;\n                emit ERC1155TokenCreated(fromChainHash, token, address(contractOnSchain));\n            }\n        }\n        if (\n            messageType == Messages.MessageType.TRANSFER_ERC1155 &&\n            fromChainHash != MAINNET_HASH &&\n            _schainToERC1155[fromChainHash].contains(token)\n        ) {\n            require(token.isContract(), \"Incorrect main chain token\");\n            _removeTransferredAmount(fromChainHash, token, _asSingletonArray(id), _asSingletonArray(amount));\n            IERC1155Upgradeable(token).safeTransferFrom(address(this), receiver, id, amount, \"\");\n        } else {\n            contractOnSchain.mint(receiver, id, amount, \"\");\n        }\n        emit ERC1155TokenReceived(\n            fromChainHash,\n            token,\n            address(contractOnSchain),\n            _asSingletonArray(id),\n            _asSingletonArray(amount)\n        );\n        return receiver;\n    }\n\n    /**\n     * @dev Allows TokenManager to send a batch of ERC1155 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC1155Batch(bytes32 fromChainHash, bytes calldata data) private returns (address) {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        address receiver;\n        address token;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n        ERC1155OnChain contractOnSchain;\n        if (messageType == Messages.MessageType.TRANSFER_ERC1155_BATCH){\n            Messages.TransferErc1155BatchMessage memory message = Messages.decodeTransferErc1155BatchMessage(data);\n            receiver = message.receiver;\n            token = message.token;\n            ids = message.ids;\n            amounts = message.amounts;\n            contractOnSchain = clonesErc1155[fromChainHash][token];\n        } else {\n            Messages.TransferErc1155BatchAndTokenInfoMessage memory message =\n                Messages.decodeTransferErc1155BatchAndTokenInfoMessage(data);\n            receiver = message.baseErc1155Batchtransfer.receiver;\n            token = message.baseErc1155Batchtransfer.token;\n            ids = message.baseErc1155Batchtransfer.ids;\n            amounts = message.baseErc1155Batchtransfer.amounts;\n            contractOnSchain = clonesErc1155[fromChainHash][token];\n            if (address(contractOnSchain) == address(0)) {\n                require(automaticDeploy, \"Automatic deploy is disabled\");\n                contractOnSchain = new ERC1155OnChain(message.tokenInfo.uri);\n                clonesErc1155[fromChainHash][token] = contractOnSchain;\n                emit ERC1155TokenCreated(fromChainHash, token, address(contractOnSchain));\n            }\n        }\n        if (\n            messageType == Messages.MessageType.TRANSFER_ERC1155_BATCH &&\n            fromChainHash != MAINNET_HASH &&\n            _schainToERC1155[fromChainHash].contains(token)\n        ) {\n            require(token.isContract(), \"Incorrect main chain token\");\n            _removeTransferredAmount(fromChainHash, token, ids, amounts);\n            IERC1155Upgradeable(token).safeBatchTransferFrom(address(this), receiver, ids, amounts, \"\");\n        } else {\n            contractOnSchain.mintBatch(receiver, ids, amounts, \"\");\n        }\n        emit ERC1155TokenReceived(fromChainHash, token, address(contractOnSchain), ids, amounts);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 id,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC1155OnChain contractOnSchain = clonesErc1155[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC1155OnChain(contractOnMainChain);\n            require(!addedClones[contractOnSchain], \"Incorrect main chain token\");\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.isApprovedForAll(msg.sender, address(this)), \"Not allowed ERC1155 Token\");\n        bytes memory data = Messages.encodeTransferErc1155Message(contractOnMainChain, to, id, amount);\n        if (isMainChainToken) {\n            require(chainHash != MAINNET_HASH, \"Main chain token could not be transfered to Mainnet\");\n            data = _receiveERC1155(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                id,\n                amount\n            );\n            _saveTransferredAmount(\n                chainHash,\n                address(contractOnSchain),\n                _asSingletonArray(id),\n                _asSingletonArray(amount)\n            );\n            contractOnSchain.safeTransferFrom(msg.sender, address(this), id, amount, \"\");\n        } else {\n            contractOnSchain.burn(msg.sender, id, amount);\n        }\n        messageProxy.postOutgoingMessage(chainHash, messageReceiver, data);\n    }\n\n    /**\n     * @dev Burn batch of tokens on schain and send message to unlock them on target chain.\n     */\n    function _exitBatch(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC1155OnChain contractOnSchain = clonesErc1155[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC1155OnChain(contractOnMainChain);\n            require(!addedClones[contractOnSchain], \"Incorrect main chain token\");\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.isApprovedForAll(msg.sender, address(this)), \"Not allowed ERC1155 Token\");\n        bytes memory data = Messages.encodeTransferErc1155BatchMessage(contractOnMainChain, to, ids, amounts);\n        if (isMainChainToken) {\n            require(chainHash != MAINNET_HASH, \"Main chain token could not be transfered to Mainnet\");\n            data = _receiveERC1155Batch(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                ids,\n                amounts\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), ids, amounts);\n            contractOnSchain.safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n        } else {\n            contractOnSchain.burnBatch(msg.sender, ids, amounts);\n        }\n        messageProxy.postOutgoingMessage(chainHash, messageReceiver, data);\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(\n        bytes32 chainHash,\n        address erc1155Token,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) private {\n        require(ids.length == amounts.length, \"Incorrect length of arrays\");\n        for (uint256 i = 0; i < ids.length; i++)\n            transferredAmount[chainHash][erc1155Token][ids[i]] += amounts[i];\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(\n        bytes32 chainHash,\n        address erc1155Token,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) private {\n        require(ids.length == amounts.length, \"Incorrect length of arrays\");\n        for (uint256 i = 0; i < ids.length; i++)\n            transferredAmount[chainHash][erc1155Token][ids[i]] -= amounts[i];\n    }\n\n    /**\n     * @dev Allows DepositBoxERC1155 to receive ERC1155 tokens.\n     * \n     * Emits an {ERC1155TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC1155.\n     */\n    function _receiveERC1155(\n        bytes32 chainHash,\n        address erc1155OnMainChain,\n        address to,\n        uint256 id,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        bool isERC1155AddedToSchain = _schainToERC1155[chainHash].contains(erc1155OnMainChain);\n        if (!isERC1155AddedToSchain) {\n            _addERC1155ForSchain(chainHash, erc1155OnMainChain);\n            data = Messages.encodeTransferErc1155AndTokenInfoMessage(\n                erc1155OnMainChain,\n                to,\n                id,\n                amount,\n                _getTokenInfo(IERC1155MetadataURIUpgradeable(erc1155OnMainChain))\n            );\n        } else {\n            data = Messages.encodeTransferErc1155Message(erc1155OnMainChain, to, id, amount);\n        }\n        \n        emit ERC1155TokenReady(chainHash, erc1155OnMainChain, _asSingletonArray(id), _asSingletonArray(amount));\n    }\n\n    /**\n     * @dev Allows DepositBoxERC1155 to receive ERC1155 tokens.\n     * \n     * Emits an {ERC1155TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC1155.\n     */\n    function _receiveERC1155Batch(\n        bytes32 chainHash,\n        address erc1155OnMainChain,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    )\n        private\n        returns (bytes memory data)\n    {\n        bool isERC1155AddedToSchain = _schainToERC1155[chainHash].contains(erc1155OnMainChain);\n        if (!isERC1155AddedToSchain) {\n            _addERC1155ForSchain(chainHash, erc1155OnMainChain);\n            data = Messages.encodeTransferErc1155BatchAndTokenInfoMessage(\n                erc1155OnMainChain,\n                to,\n                ids,\n                amounts,\n                _getTokenInfo(IERC1155MetadataURIUpgradeable(erc1155OnMainChain))\n            );\n        } else {\n            data = Messages.encodeTransferErc1155BatchMessage(erc1155OnMainChain, to, ids, amounts);\n        }\n        emit ERC1155TokenReady(chainHash, erc1155OnMainChain, ids, amounts);\n    }\n\n    /**\n     * @dev Adds an ERC1155 token to DepositBoxERC1155.\n     * \n     * Emits an {ERC1155TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC1155ForSchain(bytes32 chainHash, address erc1155OnMainChain) private {\n        require(erc1155OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC1155[chainHash].contains(erc1155OnMainChain), \"ERC1155 Token was already added\");\n        _schainToERC1155[chainHash].add(erc1155OnMainChain);\n        emit ERC1155TokenAdded(chainHash, erc1155OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns info about ERC1155 token.\n     */\n    function _getTokenInfo(\n        IERC1155MetadataURIUpgradeable erc1155\n    )\n        private\n        view\n        returns (Messages.Erc1155TokenInfo memory)\n    {\n        return Messages.Erc1155TokenInfo({uri: erc1155.uri(0)});\n    }\n\n    /**\n     * @dev Create array with single element in it.\n     */\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory array) {\n        array = new uint256[](1);\n        array[0] = element;\n    }\n\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC1155.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ITokenManagerERC1155 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./ITokenContractManager.sol\";\n\n\ninterface ITokenManagerERC1155 is ITokenContractManager {\n    function exitToMainERC1155(\n        address contractOnMainnet,\n        uint256 id,\n        uint256 amount\n    ) external;\n    function exitToMainERC1155Batch(\n        address contractOnMainnet,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n    function transferToSchainERC1155(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 id,\n        uint256 amount\n    ) external;\n    function transferToSchainERC1155Batch(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n    function addERC1155TokenByOwner(\n        string calldata targetChainName,\n        address erc1155OnMainnet,\n        address erc1155OnSchain\n    ) external;\n}"
            },
            "contracts/schain/tokens/ERC1155OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC1155OnChain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IERC1155OnChain.sol\";\n\n\n/**\n * @title ERC1155OnChain\n * @dev ERC1155 token that is used as an automatically deployed clone of ERC1155 on mainnet.\n */\ncontract ERC1155OnChain is AccessControlEnumerableUpgradeable, ERC1155BurnableUpgradeable, IERC1155OnChain {\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory uri\n    ) initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC1155Upgradeable.__ERC1155_init(uri);\n        ERC1155BurnableUpgradeable.__ERC1155Burnable_init();\n\n        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Mint tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        external\n        override\n    {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mint(account, id, amount, data);\n    }\n\n    /**\n     * @dev Mint batch of tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        external\n        override\n    {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mintBatch(account, ids, amounts, data);\n    }\n\n    /**\n     * @dev Check if contract support {interfaceId} interface.\n     * \n     * See https://eips.ethereum.org/EIPS/eip-165 for more details.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@skalenetwork/ima-interfaces/schain/tokens/IERC1155OnChain.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IERC1155OnChain - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IERC1155OnChain {\n    function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n    function mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n}"
            },
            "contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC1155.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC1155.sol\";\n\nimport \"../DepositBox.sol\";\nimport \"../../Messages.sol\";\n\n\n/**\n * @title DepositBoxERC1155\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC1155.\n */\ncontract DepositBoxERC1155 is DepositBox, ERC1155ReceiverUpgradeable, IDepositBoxERC1155 {\n\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n\n    // schainHash => address of ERC on Mainnet\n    // Deprecated\n    // slither-disable-next-line unused-state\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedSchainToERC1155;\n    mapping(bytes32 => mapping(address => mapping(uint256 => uint256))) public transferredAmount;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC1155;\n\n    /**\n     * @dev Emitted when token is mapped in DepositBoxERC20.\n     */\n    event ERC1155TokenAdded(string schainName, address indexed contractOnMainnet);\n\n    /**\n     * @dev Emitted when token is received by DepositBox and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC1155TokenReady(address indexed contractOnMainnet, uint256[] ids, uint256[] amounts);\n\n    /**\n     * @dev Allows `msg.sender` to send ERC1155 token from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their tokens for DepositBoxERC1155 address.\n     */\n    function depositERC1155(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        uint256 id,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            IERC1155Upgradeable(erc1155OnMainnet).isApprovedForAll(msg.sender, address(this)),\n            \"DepositBox was not approved for ERC1155 token\"\n        );\n        bytes memory data = _receiveERC1155(\n            schainName,\n            erc1155OnMainnet,\n            msg.sender,\n            id,\n            amount\n        );\n        _saveTransferredAmount(schainHash, erc1155OnMainnet, _asSingletonArray(id), _asSingletonArray(amount));\n        IERC1155Upgradeable(erc1155OnMainnet).safeTransferFrom(msg.sender, address(this), id, amount, \"\");\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows `msg.sender` to send batch of ERC1155 tokens from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their tokens for DepositBoxERC1155 address.\n     */\n    function depositERC1155Batch(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            IERC1155Upgradeable(erc1155OnMainnet).isApprovedForAll(msg.sender, address(this)),\n            \"DepositBox was not approved for ERC1155 token Batch\"\n        );\n        bytes memory data = _receiveERC1155Batch(\n            schainName,\n            erc1155OnMainnet,\n            msg.sender,\n            ids,\n            amounts\n        );\n        _saveTransferredAmount(schainHash, erc1155OnMainnet, ids, amounts);\n        IERC1155Upgradeable(erc1155OnMainnet).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC1155 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be added to DepositBoxERC1155 and schain name cannot be `Mainnet`.\n     * - Amount of tokens on DepositBoxERC1155 should be equal or more than transferred amount.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        if (operation == Messages.MessageType.TRANSFER_ERC1155) {\n            Messages.TransferErc1155Message memory message = Messages.decodeTransferErc1155Message(data);\n            require(message.token.isContract(), \"Given address is not a contract\");\n            _removeTransferredAmount(\n                schainHash,\n                message.token,\n                _asSingletonArray(message.id),\n                _asSingletonArray(message.amount)\n            );\n            IERC1155Upgradeable(message.token).safeTransferFrom(\n                address(this),\n                message.receiver,\n                message.id,\n                message.amount,\n                \"\"\n            );\n        } else if (operation == Messages.MessageType.TRANSFER_ERC1155_BATCH) {\n            Messages.TransferErc1155BatchMessage memory message = Messages.decodeTransferErc1155BatchMessage(data);\n            require(message.token.isContract(), \"Given address is not a contract\");\n            _removeTransferredAmount(schainHash, message.token, message.ids, message.amounts);\n            IERC1155Upgradeable(message.token).safeBatchTransferFrom(\n                address(this),\n                message.receiver,\n                message.ids,\n                message.amounts,\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev Allows Schain owner to add an ERC1155 token to DepositBoxERC1155.\n     * \n     * Emits an {ERC1155TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Schain should not be killed.\n     * - Only owner of the schain able to run function.\n     */\n    function addERC1155TokenByOwner(\n        string calldata schainName,\n        address erc1155OnMainnet\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        _addERC1155ForSchain(schainName, erc1155OnMainnet);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their tokens.\n     * The Schain owner decides which tokens to send to which address, \n     * since the contract on mainnet does not store information about which tokens belong to whom.\n     *\n     * Requirements:\n     * \n     * - Amount of tokens on schain should be equal or more than transferred amount.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(ids.length == amounts.length, \"Incorrect length of arrays\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(transferredAmount[schainHash][erc1155OnMainnet][ids[i]] >= amounts[i], \"Incorrect amount\");\n        }\n        _removeTransferredAmount(schainHash, erc1155OnMainnet, ids, amounts);\n        IERC1155Upgradeable(erc1155OnMainnet).safeBatchTransferFrom(\n            address(this),\n            receiver,\n            ids,\n            amounts,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        if (operation == Messages.MessageType.TRANSFER_ERC1155) {\n            Messages.TransferErc1155Message memory message = Messages.decodeTransferErc1155Message(data);\n            return message.receiver;\n        } else if (operation == Messages.MessageType.TRANSFER_ERC1155_BATCH) {\n            Messages.TransferErc1155BatchMessage memory message = Messages.decodeTransferErc1155BatchMessage(data);\n            return message.receiver;\n        }\n        return address(0);\n    }\n\n\n    /**\n     * @dev Returns selector of onERC1155Received.\n     */\n    function onERC1155Received(\n        address operator,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns(bytes4)\n    {\n        require(operator == address(this), \"Revert ERC1155 transfer\");\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }\n\n\n    /**\n     * @dev Returns selector of onERC1155BatchReceived.\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns(bytes4)\n    {\n        require(operator == address(this), \"Revert ERC1155 batch transfer\");\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }\n\n    /**\n     * @dev Should return true if token was added by Schain owner or \n     * added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToERC1155(\n        string calldata schainName,\n        address erc1155OnMainnet\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _schainToERC1155[keccak256(abi.encodePacked(schainName))].contains(erc1155OnMainnet);\n    }\n\n    /**\n     * @dev Should return length of a set of all mapped tokens which were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC1155Length(string calldata schainName) external view override returns (uint256) {\n        return _schainToERC1155[keccak256(abi.encodePacked(schainName))].length();\n    }\n\n    /**\n     * @dev Should return an array of tokens were added by Schain owner or \n     * added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC1155(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory tokensInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _schainToERC1155[keccak256(abi.encodePacked(schainName))].length(),\n            \"Range is incorrect\"\n        );\n        tokensInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            tokensInRange[i - from] = _schainToERC1155[keccak256(abi.encodePacked(schainName))].at(i);\n        }\n    }\n\n    /**\n     * @dev Creates a new DepositBoxERC1155 contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,        \n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n        __ERC1155Receiver_init();\n    }\n\n    /**\n     * @dev Checks whether contract supports such interface (first 4 bytes of method name and its params).\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(AccessControlEnumerableUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(Twin).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(\n        bytes32 schainHash,\n        address erc1155Token,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) private {\n        require(ids.length == amounts.length, \"Incorrect length of arrays\");\n        for (uint256 i = 0; i < ids.length; i++)\n            transferredAmount[schainHash][erc1155Token][ids[i]] =\n                transferredAmount[schainHash][erc1155Token][ids[i]] + amounts[i];\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(\n        bytes32 schainHash,\n        address erc1155Token,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) private {\n        require(ids.length == amounts.length, \"Incorrect length of arrays\");\n        for (uint256 i = 0; i < ids.length; i++)\n            transferredAmount[schainHash][erc1155Token][ids[i]] =\n                transferredAmount[schainHash][erc1155Token][ids[i]] - amounts[i];\n    }\n\n    /**\n     * @dev Allows DepositBoxERC1155 to receive ERC1155 tokens.\n     * \n     * Emits an {ERC1155TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC1155.\n     */\n    function _receiveERC1155(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        address to,\n        uint256 id,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        bool isERC1155AddedToSchain = _schainToERC1155[schainHash].contains(erc1155OnMainnet);\n        if (!isERC1155AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC1155ForSchain(schainName, erc1155OnMainnet);\n            data = Messages.encodeTransferErc1155AndTokenInfoMessage(\n                erc1155OnMainnet,\n                to,\n                id,\n                amount,\n                _getTokenInfo(IERC1155MetadataURIUpgradeable(erc1155OnMainnet))\n            );\n        } else {\n            data = Messages.encodeTransferErc1155Message(erc1155OnMainnet, to, id, amount);\n        }\n        \n        emit ERC1155TokenReady(erc1155OnMainnet, _asSingletonArray(id), _asSingletonArray(amount));\n    }\n\n    /**\n     * @dev Allows DepositBoxERC1155 to receive ERC1155 tokens.\n     * \n     * Emits an {ERC1155TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC1155.\n     */\n    function _receiveERC1155Batch(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    )\n        private\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        bool isERC1155AddedToSchain = _schainToERC1155[schainHash].contains(erc1155OnMainnet);\n        if (!isERC1155AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC1155ForSchain(schainName, erc1155OnMainnet);\n            data = Messages.encodeTransferErc1155BatchAndTokenInfoMessage(\n                erc1155OnMainnet,\n                to,\n                ids,\n                amounts,\n                _getTokenInfo(IERC1155MetadataURIUpgradeable(erc1155OnMainnet))\n            );\n        } else {\n            data = Messages.encodeTransferErc1155BatchMessage(erc1155OnMainnet, to, ids, amounts);\n        }\n        emit ERC1155TokenReady(erc1155OnMainnet, ids, amounts);\n    }\n\n    /**\n     * @dev Adds an ERC1155 token to DepositBoxERC1155.\n     * \n     * Emits an {ERC1155TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC1155ForSchain(string calldata schainName, address erc1155OnMainnet) private {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(erc1155OnMainnet.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC1155[schainHash].contains(erc1155OnMainnet), \"ERC1155 Token was already added\");\n        _schainToERC1155[schainHash].add(erc1155OnMainnet);\n        emit ERC1155TokenAdded(schainName, erc1155OnMainnet);\n    }\n\n    /**\n     * @dev Returns info about ERC1155 token.\n     */\n    function _getTokenInfo(\n        IERC1155MetadataURIUpgradeable erc1155\n    )\n        private\n        view\n        returns (Messages.Erc1155TokenInfo memory)\n    {\n        return Messages.Erc1155TokenInfo({uri: erc1155.uri(0)});\n    }\n\n    /**\n     * @dev Returns array with single element that passed as argument.\n     */\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory array) {\n        array = new uint256[](1);\n        array[0] = element;\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
            },
            "@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC1155.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IDepositBoxERC1155.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IDepositBox.sol\";\n\n\ninterface IDepositBoxERC1155 is IDepositBox {\n    function depositERC1155(string calldata schainName, address erc1155OnMainnet, uint256 id, uint256 amount) external;\n    function depositERC1155Batch(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external;\n    function addERC1155TokenByOwner(string calldata schainName, address erc1155OnMainnet) external;\n    function getFunds(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n    function getSchainToERC1155(string calldata schainName, address erc1155OnMainnet) external view returns (bool);\n    function getSchainToAllERC1155Length(string calldata schainName) external view returns (uint256);\n    function getSchainToAllERC1155(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        returns (address[] memory);\n}"
            },
            "contracts/mainnet/DepositBoxes/DepositBoxERC20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../DepositBox.sol\";\n\ninterface IERC20TransferVoid {\n    function transferFrom(address _from, address _to, uint256 _amount) external;\n    function transfer(address _to, uint256 _amount) external;\n}\n\n\n/**\n * @title DepositBoxERC20\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC20.\n */\ncontract DepositBoxERC20 is DepositBox, IDepositBoxERC20 {\n    using AddressUpgradeable for address;\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    enum DelayedTransferStatus {\n        DELAYED,\n        ARBITRAGE,\n        COMPLETED\n    }\n\n    struct DelayedTransfer {\n        address receiver;\n        bytes32 schainHash;\n        address token;\n        uint256 amount;\n        uint256 untilTimestamp;\n        DelayedTransferStatus status;\n    }\n\n    struct DelayConfig {\n        // token address => value\n        mapping(address => uint256) bigTransferThreshold;\n        EnumerableSetUpgradeable.AddressSet trustedReceivers;\n        uint256 transferDelay;\n        uint256 arbitrageDuration;\n    }\n\n    uint256 private constant _QUEUE_PROCESSING_LIMIT = 10;\n\n    bytes32 public constant ARBITER_ROLE = keccak256(\"ARBITER_ROLE\");\n\n    // schainHash => address of ERC20 on Mainnet\n    // Deprecated\n    // slither-disable-next-line unused-state\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedSchainToERC20;\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    // exits delay configuration\n    //   schainHash => delay config\n    mapping(bytes32 => DelayConfig) private _delayConfig;\n\n    uint256 public delayedTransfersSize;\n    // delayed transfer id => delayed transfer\n    mapping(uint256 => DelayedTransfer) public delayedTransfers;\n    // receiver address => delayed transfers ids queue\n    mapping(address => DoubleEndedQueueUpgradeable.Bytes32Deque) public delayedTransfersByReceiver;\n\n    /**\n     * @dev Emitted when token is mapped in DepositBoxERC20.\n     */\n    event ERC20TokenAdded(string schainName, address indexed contractOnMainnet);\n\n    /**\n     * @dev Emitted when token is received by DepositBox and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(address indexed contractOnMainnet, uint256 amount);\n\n    event TransferDelayed(uint256 id, address receiver, address token, uint256 amount);\n\n    event Escalated(uint256 id);\n\n    /**\n     * @dev Emitted when token transfer is skipped due to internal token error\n     */\n    event TransferSkipped(uint256 id);\n\n    /**\n     * @dev Emitted when big transfer threshold is changed\n     */\n    event BigTransferThresholdIsChanged(\n        bytes32 indexed schainHash,\n        address indexed token,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when big transfer delay is changed\n     */\n    event BigTransferDelayIsChanged(\n        bytes32 indexed schainHash,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when arbitrage duration is changed\n     */\n    event ArbitrageDurationIsChanged(\n        bytes32 indexed schainHash,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Allows `msg.sender` to send ERC20 token from mainnet to schain\n     *\n     * Requirements:\n     *\n     * - Schain name must not be `Mainnet`.\n     * - Receiver account on schain cannot be null.\n     * - Schain that receives tokens should not be killed.\n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their tokens for DepositBoxERC20 address.\n     */\n    function depositERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(_schainHash(schainName))\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            IERC20MetadataUpgradeable(erc20OnMainnet).allowance(msg.sender, address(this)) >= amount,\n            \"DepositBox was not approved for ERC20 token\"\n        );\n        bytes memory data = _receiveERC20(\n            schainName,\n            erc20OnMainnet,\n            msg.sender,\n            amount\n        );\n        _saveTransferredAmount(schainHash, erc20OnMainnet, amount);\n        IERC20MetadataUpgradeable(erc20OnMainnet).safeTransferFrom(msg.sender, address(this), amount);\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC20 token from schain to mainnet.\n     *\n     * Requirements:\n     *\n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - Amount of tokens on DepositBoxERC20 should be equal or more than transferred amount.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(\n            IERC20MetadataUpgradeable(message.token).balanceOf(address(this)) >= message.amount,\n            \"Not enough money\"\n        );\n        _removeTransferredAmount(schainHash, message.token, message.amount);\n\n        uint256 delay = _delayConfig[schainHash].transferDelay;\n        if (\n            delay > 0\n            && _delayConfig[schainHash].bigTransferThreshold[message.token] <= message.amount\n            && !isReceiverTrusted(schainHash, message.receiver)\n        ) {\n            _createDelayedTransfer(schainHash, message, delay);\n        } else {\n            IERC20MetadataUpgradeable(message.token).safeTransfer(message.receiver, message.amount);\n        }\n    }\n\n    /**\n     * @dev Allows Schain owner to add an ERC20 token to DepositBoxERC20.\n     *\n     * Emits an {ERC20TokenAdded} event.\n     *\n     * Requirements:\n     *\n     * - Schain should not be killed.\n     * - Only owner of the schain able to run function.\n     */\n    function addERC20TokenByOwner(string calldata schainName, address erc20OnMainnet)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(_schainHash(schainName))\n    {\n        _addERC20ForSchain(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their tokens.\n     * The Schain owner decides which tokens to send to which address,\n     * since the contract on mainnet does not store information about which tokens belong to whom.\n     *\n     * Requirements:\n     *\n     * - Amount of tokens on schain should be equal or more than transferred amount.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(_schainHash(schainName))\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        require(transferredAmount[schainHash][erc20OnMainnet] >= amount, \"Incorrect amount\");\n        _removeTransferredAmount(schainHash, erc20OnMainnet, amount);\n        IERC20MetadataUpgradeable(erc20OnMainnet).safeTransfer(receiver, amount);\n    }\n\n    /**\n     * @dev Set a threshold amount of tokens.\n     * If amount of tokens that exits IMA is bigger than the threshold\n     * the transfer is delayed for configurable amount of time\n     * and can be canceled by a voting\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     */\n    function setBigTransferValue(\n        string calldata schainName,\n        address token,\n        uint256 value\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        emit BigTransferThresholdIsChanged(\n            schainHash,\n            token,\n            _delayConfig[schainHash].bigTransferThreshold[token],\n            value\n        );\n        _delayConfig[schainHash].bigTransferThreshold[token] = value;\n    }\n\n    /**\n     * @dev Set a time delay.\n     * If amount of tokens that exits IMA is bigger than a threshold\n     * the transfer is delayed for set amount of time\n     * and can be canceled by a voting\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     */\n    function setBigTransferDelay(\n        string calldata schainName,\n        uint256 delayInSeconds\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        // need to restrict big delays to avoid overflow\n        require(delayInSeconds < 1e8, \"Delay is too big\"); // no more then ~ 3 years\n        emit BigTransferDelayIsChanged(schainHash, _delayConfig[schainHash].transferDelay, delayInSeconds);\n        _delayConfig[schainHash].transferDelay = delayInSeconds;\n    }\n\n    /**\n     * @dev Set an arbitrage.\n     * After escalation the transfer is locked for provided period of time.\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     */\n    function setArbitrageDuration(\n        string calldata schainName,\n        uint256 delayInSeconds\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        // need to restrict big delays to avoid overflow\n        require(delayInSeconds < 1e8, \"Delay is too big\"); // no more then ~ 3 years\n        emit ArbitrageDurationIsChanged(schainHash, _delayConfig[schainHash].arbitrageDuration, delayInSeconds);\n        _delayConfig[schainHash].arbitrageDuration = delayInSeconds;\n    }\n\n    /**\n     * @dev Add the address to a whitelist of addresses that can do big transfers without delaying\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - the address must not be in the whitelist\n     */\n    function trustReceiver(\n        string calldata schainName,\n        address receiver\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n    {\n        require(\n            _delayConfig[_schainHash(schainName)].trustedReceivers.add(receiver),\n            \"Receiver already is trusted\"\n        );\n    }\n\n    /**\n     * @dev Remove the address from a whitelist of addresses that can do big transfers without delaying\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - the address must be in the whitelist\n     */\n    function stopTrustingReceiver(\n        string calldata schainName,\n        address receiver\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n    {\n        require(_delayConfig[_schainHash(schainName)].trustedReceivers.remove(receiver), \"Receiver is not trusted\");\n    }\n\n    /**\n     * @dev Transfers tokens that was locked for delay during exit process.\n     * Must be called by a receiver.\n     */\n    function retrieve() external override {\n        retrieveFor(msg.sender);\n    }\n\n    /**\n     * @dev Initialize arbitrage of a suspicious big transfer\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain or have ARBITER_ROLE role\n     * - transfer must be delayed and arbitrage must not be started\n     */\n    function escalate(uint256 transferId) external override {\n        bytes32 schainHash = delayedTransfers[transferId].schainHash;\n        require(\n            hasRole(ARBITER_ROLE, msg.sender) || isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to request escalation\"\n        );\n        require(delayedTransfers[transferId].status == DelayedTransferStatus.DELAYED, \"The transfer has to be delayed\");\n        delayedTransfers[transferId].status = DelayedTransferStatus.ARBITRAGE;\n        delayedTransfers[transferId].untilTimestamp = MathUpgradeable.max(\n            delayedTransfers[transferId].untilTimestamp,\n            block.timestamp + _delayConfig[schainHash].arbitrageDuration\n        );\n        emit Escalated(transferId);\n    }\n\n    /**\n     * @dev Approve a big transfer and immidiately transfer tokens during arbitrage\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - arbitrage of the transfer must be started\n     */\n    function validateTransfer(\n        uint transferId\n    )\n        external\n        override\n        onlySchainOwnerByHash(delayedTransfers[transferId].schainHash)\n    {\n        DelayedTransfer storage transfer = delayedTransfers[transferId];\n        require(transfer.status == DelayedTransferStatus.ARBITRAGE, \"Arbitrage has to be active\");\n        transfer.status = DelayedTransferStatus.COMPLETED;\n        delete transfer.untilTimestamp;\n        IERC20MetadataUpgradeable(transfer.token).safeTransfer(transfer.receiver, transfer.amount);\n    }\n\n    /**\n     * @dev Reject a big transfer and transfer tokens to SKALE chain owner during arbitrage\n     *\n     * Requirements:\n     *\n     * - msg.sender should be an owner of schain\n     * - arbitrage of the transfer must be started\n     */\n    function rejectTransfer(\n        uint transferId\n    )\n        external\n        override\n        onlySchainOwnerByHash(delayedTransfers[transferId].schainHash)\n    {\n        DelayedTransfer storage transfer = delayedTransfers[transferId];\n        require(transfer.status == DelayedTransferStatus.ARBITRAGE, \"Arbitrage has to be active\");\n        transfer.status = DelayedTransferStatus.COMPLETED;\n        delete transfer.untilTimestamp;\n        // msg.sender is schain owner\n        IERC20MetadataUpgradeable(transfer.token).safeTransfer(msg.sender, transfer.amount);\n    }\n\n    function doTransfer(address token, address receiver, uint256 amount) external override {\n        require(msg.sender == address(this), \"Internal use only\");\n        IERC20Upgradeable(token).safeTransfer(receiver, amount);\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        return message.receiver;\n    }\n\n    /**\n     * @dev Should return true if token was added by Schain owner or\n     * added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToERC20(\n        string calldata schainName,\n        address erc20OnMainnet\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _schainToERC20[_schainHash(schainName)].contains(erc20OnMainnet);\n    }\n\n    /**\n     * @dev Should return length of a set of all mapped tokens which were added by Schain owner\n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20Length(string calldata schainName) external view override returns (uint256) {\n        return _schainToERC20[_schainHash(schainName)].length();\n    }\n\n    /**\n     * @dev Should return an array of range of tokens were added by Schain owner\n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory tokensInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _schainToERC20[_schainHash(schainName)].length(),\n            \"Range is incorrect\"\n        );\n        tokensInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            tokensInRange[i - from] = _schainToERC20[_schainHash(schainName)].at(i);\n        }\n    }\n\n    /**\n     * @dev Get amount of tokens that are delayed for specified receiver\n     */\n    function getDelayedAmount(address receiver, address token) external view override returns (uint256 value) {\n        uint256 delayedTransfersAmount = delayedTransfersByReceiver[receiver].length();\n        for (uint256 i = 0; i < delayedTransfersAmount; ++i) {\n            DelayedTransfer storage transfer = delayedTransfers[uint256(delayedTransfersByReceiver[receiver].at(i))];\n            DelayedTransferStatus status = transfer.status;\n            if (transfer.token == token) {\n                if (status == DelayedTransferStatus.DELAYED || status == DelayedTransferStatus.ARBITRAGE) {\n                    value += transfer.amount;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get timestamp of next unlock of tokens that are delayed for specified receiver\n     */\n    function getNextUnlockTimestamp(\n        address receiver,\n        address token\n    )\n        external\n        view\n        override\n        returns (uint256 unlockTimestamp)\n    {\n        uint256 delayedTransfersAmount = delayedTransfersByReceiver[receiver].length();\n        unlockTimestamp = type(uint256).max;\n        for (uint256 i = 0; i < delayedTransfersAmount; ++i) {\n            DelayedTransfer storage transfer = delayedTransfers[uint256(delayedTransfersByReceiver[receiver].at(i))];\n            DelayedTransferStatus status = transfer.status;\n            if (transfer.token == token) {\n                if (status != DelayedTransferStatus.COMPLETED) {\n                    unlockTimestamp = MathUpgradeable.min(unlockTimestamp, transfer.untilTimestamp);\n                }\n                if (status == DelayedTransferStatus.DELAYED) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get amount of addresses that are added to the whitelist\n     */\n    function getTrustedReceiversAmount(bytes32 schainHash) external view override returns (uint256) {\n        return _delayConfig[schainHash].trustedReceivers.length();\n    }\n\n    /**\n     * @dev Get i-th address of the whitelist\n     */\n    function getTrustedReceiver(string calldata schainName, uint256 index) external view override returns (address) {\n        return _delayConfig[_schainHash(schainName)].trustedReceivers.at(index);\n    }\n\n    /**\n     * @dev Get amount of tokens that are considered as a big transfer\n     */\n    function getBigTransferThreshold(bytes32 schainHash, address token) external view override returns (uint256) {\n        return _delayConfig[schainHash].bigTransferThreshold[token];\n    }\n\n    /**\n     * @dev Get time delay of big transfers\n     */\n    function getTimeDelay(bytes32 schainHash) external view override returns (uint256) {\n        return _delayConfig[schainHash].transferDelay;\n    }\n\n    /**\n     * @dev Get duration of an arbitrage\n     */\n    function getArbitrageDuration(bytes32 schainHash) external view override returns (uint256) {\n        return _delayConfig[schainHash].arbitrageDuration;\n    }\n\n    /**\n     * @dev Retrive tokens that were unlocked after delay for specified receiver\n     */\n    function retrieveFor(address receiver) public override {\n        uint256 transfersAmount = MathUpgradeable.min(\n            delayedTransfersByReceiver[receiver].length(),\n            _QUEUE_PROCESSING_LIMIT\n        );\n\n        uint256 currentIndex = 0;\n        bool retrieved = false;\n        for (uint256 i = 0; i < transfersAmount; ++i) {\n            uint256 transferId = uint256(delayedTransfersByReceiver[receiver].at(currentIndex));\n            DelayedTransfer memory transfer = delayedTransfers[transferId];\n            ++currentIndex;\n\n            if (transfer.status != DelayedTransferStatus.COMPLETED) {\n                if (block.timestamp < transfer.untilTimestamp) {\n                    // disable detector untill slither fixes false positive\n                    // https://github.com/crytic/slither/issues/778\n                    // slither-disable-next-line incorrect-equality\n                    if (transfer.status == DelayedTransferStatus.DELAYED) {\n                        break;\n                    } else {\n                        // status is ARBITRAGE\n                        continue;\n                    }\n                } else {\n                    // it's time to unlock\n                    if (currentIndex == 1) {\n                        --currentIndex;\n                        _removeOldestDelayedTransfer(receiver);\n                    } else {\n                        delayedTransfers[transferId].status = DelayedTransferStatus.COMPLETED;\n                    }\n                    retrieved = true;\n                    try\n                        this.doTransfer(transfer.token, transfer.receiver, transfer.amount)\n                    // solhint-disable-next-line no-empty-blocks\n                    {}\n                    catch {\n                        emit TransferSkipped(transferId);\n                    }\n                }\n            } else {\n                // status is COMPLETED\n                if (currentIndex == 1) {\n                    --currentIndex;\n                    retrieved = true;\n                    _removeOldestDelayedTransfer(receiver);\n                }\n            }\n        }\n        require(retrieved, \"There are no transfers available for retrieving\");\n    }\n\n    /**\n     * @dev Creates a new DepositBoxERC20 contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n    }\n\n    /**\n     * @dev Check if the receiver is in the delay whitelist\n     */\n    function isReceiverTrusted(bytes32 schainHash, address receiver) public view override returns (bool) {\n        return _delayConfig[schainHash].trustedReceivers.contains(receiver);\n    }\n\n    // private\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     *\n     * Emits an {ERC20TokenReady} event.\n     *\n     * Requirements:\n     *\n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = _schainHash(schainName);\n        IERC20MetadataUpgradeable erc20 = IERC20MetadataUpgradeable(erc20OnMainnet);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[schainHash].contains(erc20OnMainnet);\n        if (!isERC20AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC20ForSchain(schainName, erc20OnMainnet);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(erc20OnMainnet, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     *\n     * Emits an {ERC20TokenAdded} event.\n     *\n     * Requirements:\n     *\n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(string calldata schainName, address erc20OnMainnet) private {\n        bytes32 schainHash = _schainHash(schainName);\n        require(erc20OnMainnet.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[schainHash].contains(erc20OnMainnet), \"ERC20 Token was already added\");\n        _schainToERC20[schainHash].add(erc20OnMainnet);\n        emit ERC20TokenAdded(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Add delayed transfer to receiver specific queue\n     */\n    function _addToDelayedQueue(\n        address receiver,\n        uint256 id,\n        uint256 until\n    )\n        private\n    {\n        _addToDelayedQueueWithPriority(delayedTransfersByReceiver[receiver], id, until, _QUEUE_PROCESSING_LIMIT);\n    }\n\n    /**\n     * @dev Add delayed transfer to receiver specific queue at the position\n     * that maintains order from earlier unlocked to later unlocked.\n     * If the position is located further than depthLimit from the back\n     * the element is added at back - depthLimit index\n     */\n    function _addToDelayedQueueWithPriority(\n        DoubleEndedQueueUpgradeable.Bytes32Deque storage queue,\n        uint256 id,\n        uint256 until,\n        uint256 depthLimit\n    )\n        private\n    {\n        if (depthLimit == 0 || queue.empty()) {\n            queue.pushBack(bytes32(id));\n        } else {\n            if (delayedTransfers[uint256(queue.back())].untilTimestamp <= until) {\n                queue.pushBack(bytes32(id));\n            } else {\n                bytes32 lowPriorityValue = queue.popBack();\n                _addToDelayedQueueWithPriority(queue, id, until, depthLimit - 1);\n                queue.pushBack(lowPriorityValue);\n            }\n        }\n    }\n\n    /**\n     * Create instance of DelayedTransfer and initialize all auxiliary fields.\n     */\n    function _createDelayedTransfer(\n        bytes32 schainHash,\n        Messages.TransferErc20Message memory message,\n        uint256 delay\n    )\n        private\n    {\n        uint256 delayId = delayedTransfersSize++;\n        delayedTransfers[delayId] = DelayedTransfer({\n            receiver: message.receiver,\n            schainHash: schainHash,\n            token: message.token,\n            amount: message.amount,\n            untilTimestamp: block.timestamp + delay,\n            status: DelayedTransferStatus.DELAYED\n        });\n        _addToDelayedQueue(message.receiver, delayId, block.timestamp + delay);\n        emit TransferDelayed(delayId, message.receiver, message.token, message.amount);\n    }\n\n    /**\n     * Remove instance of DelayedTransfer and clean auxiliary fields.\n     */\n    function _removeOldestDelayedTransfer(address receiver) private {\n        uint256 transferId = uint256(delayedTransfersByReceiver[receiver].popFront());\n        // For most cases the loop will have only 1 iteration.\n        // In worst case the amount of iterations is limited by _QUEUE_PROCESSING_LIMIT\n        // slither-disable-next-line costly-loop\n        delete delayedTransfers[transferId];\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(IERC20MetadataUpgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(IERC20MetadataUpgradeable erc20Token)\n        private\n        view\n        returns (Messages.Erc20TokenInfo memory)\n    {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
            },
            "@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
            },
            "@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IDepositBoxERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"../IDepositBox.sol\";\n\n\ninterface IDepositBoxERC20 is IDepositBox {\n    function addERC20TokenByOwner(string calldata schainName, address erc20OnMainnet) external;\n    function depositERC20(string calldata schainName, address erc20OnMainnet, uint256 amount) external;\n    function doTransfer(address token, address receiver, uint256 amount) external;\n    function escalate(uint256 transferId) external;\n    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount) external;\n    function rejectTransfer(uint transferId) external;\n    function retrieve() external;\n    function retrieveFor(address receiver) external;\n    function setArbitrageDuration(string calldata schainName, uint256 delayInSeconds) external;\n    function setBigTransferValue(string calldata schainName, address token, uint256 value) external;\n    function setBigTransferDelay(string calldata schainName, uint256 delayInSeconds) external;\n    function stopTrustingReceiver(string calldata schainName, address receiver) external;\n    function trustReceiver(string calldata schainName, address receiver) external;\n    function validateTransfer(uint transferId) external;\n    function isReceiverTrusted(bytes32 schainHash, address receiver) external view returns (bool);\n    function getArbitrageDuration(bytes32 schainHash) external view returns (uint256);\n    function getBigTransferThreshold(bytes32 schainHash, address token) external view returns (uint256);\n    function getDelayedAmount(address receiver, address token) external view returns (uint256 value);\n    function getNextUnlockTimestamp(address receiver, address token) external view returns (uint256 unlockTimestamp);\n    function getSchainToERC20(string calldata schainName, address erc20OnMainnet) external view returns (bool);\n    function getSchainToAllERC20Length(string calldata schainName) external view returns (uint256);\n    function getSchainToAllERC20(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        returns (address[] memory);\n    function getTimeDelay(bytes32 schainHash) external view returns (uint256);\n    function getTrustedReceiver(string calldata schainName, uint256 index) external view returns (address);\n    function getTrustedReceiversAmount(bytes32 schainHash) external view returns (uint256);\n}"
            },
            "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
                "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
            },
            "contracts/schain/tokens/EthErc20.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   EthErc20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol\";\n\n\n/**\n * @title EthErc20\n * @dev ERC20 token that represents ETH on mainnet.\n */\ncontract EthErc20 is AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, IEthErc20 {\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /**\n     * @dev id of a role that allows token burning.\n     */\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    /**\n     * @dev Mint tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(address account, uint256 amount) external override {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"MINTER role is required\");\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Burn tokens for any account.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {BURNER_ROLE}.\n     */\n    function forceBurn(address account, uint256 amount) external override {\n        require(hasRole(BURNER_ROLE, _msgSender()), \"BURNER role is required\");\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(address tokenManagerEthAddress)\n        external\n        override\n        initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC20Upgradeable.__ERC20_init(\"ERC20 Ether Clone\", \"ETHC\");\n        ERC20BurnableUpgradeable.__ERC20Burnable_init();        \n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(MINTER_ROLE, tokenManagerEthAddress);\n        _setupRole(BURNER_ROLE, tokenManagerEthAddress);\n    }\n}\n"
            },
            "contracts/test/SafeMock.sol": {
                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    SafeMock.sol - SKALE Interchain Messaging Agent\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE IMA is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE IMA is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ninterface ISafeMock {\n    enum Operation {Call, DelegateCall}\n\n    function transferProxyAdminOwnership(OwnableUpgradeable proxyAdmin, address newOwner) external;\n    function destroy() external;\n    function multiSend(bytes memory transactions) external;\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n}\n\ncontract SafeMock is OwnableUpgradeable, ISafeMock {\n\n    bool public constant IS_SAFE_MOCK = true;\n    bytes32 public constant SAFE_TX_TYPE_HASH = keccak256(\n        \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,\"\n        \"address gasToken,address refundReceiver,uint256 nonce)\"\n    );\n    bytes32 public constant DOMAIN_SEPARATOR_TYPE_HASH = keccak256(\n        \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    );\n\n    constructor() initializer {\n        OwnableUpgradeable.__Ownable_init();\n        multiSend(\"\"); // this is needed to remove slither warning\n    }\n\n    function transferProxyAdminOwnership(OwnableUpgradeable proxyAdmin, address newOwner) external override onlyOwner {\n        proxyAdmin.transferOwnership(newOwner);\n    }\n\n    function destroy() external override onlyOwner {\n        selfdestruct(payable(msg.sender));\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    function multiSend(bytes memory transactions) public override\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            // solhint-disable-next-line no-empty-blocks\n            for { } lt(i, length) { } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right \n                // since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes])\n                // to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte\n                // (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 { success := call(gas(), to, value, data, dataLength, 0, 0) }\n                case 1 { success := delegatecall(gas(), to, data, dataLength, 0, 0) }\n                if eq(success, 0) { revert(0, 0) }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view override returns (bytes32) {\n        return keccak256(\n            _encodeTransactionData(\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution\n    ///                (e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function _encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) private view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPE_HASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), _domainSeparator(), safeTxHash);\n    }\n\n    function _domainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPE_HASH, block.chainid, this));\n    }\n}"
            }
        },
        "settings": {
            "optimizer": {
                "enabled": true,
                "runs": 200
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "evm.bytecode",
                        "evm.deployedBytecode",
                        "evm.methodIdentifiers"
                    ],
                    "": [
                        "ast"
                    ]
                }
            }
        }
    }
}